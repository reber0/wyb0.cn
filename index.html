<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.140.2"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=author content="Reber"><title>Reber's Blog</title>
<link rel=stylesheet href=/css/reset.css><link rel=stylesheet href=/css/smigle.css><link rel=stylesheet href=/css/monokai-sublime.min.css><link rel=stylesheet href=/css/style.css><script src=/js/jquery-3.6.0.min.js></script><script src=/js/highlight.min.js></script><script src=/js/style.js></script><link rel=icon type=image/img sizes=16x16 href=/img/logo.png><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"></head><body><header><div id=brand><a class=icon-link href=https://wyb0.com/><img class=icon src=/img/logo.png></a><div class=text><a href=https://wyb0.com/><h1>Reber's Blog</h1></a><h3>会一点点编程、会一点点渗透</h3></div></div><nav><a href=/><b>Home</b></a>
|
<a href=/posts/><b>Posts</b></a>
|
<a href=/categories/><b>Categories</b></a>
|
<a href=/tags/><b>Tags</b></a>
|
<a href=/about/><b>About</b></a>
|
<a href=/friends/><b>Friends</b></a></nav><hr></header><div id=content><main><article><h1 class=summary-title><a href=https://wyb0.com/posts/2024/android-calls-so-file/>安卓调用 so 文件</a></h1><div class=post-meta><time>2024-05-17</time>
[<a href=/categories/Code>Code</a>](<a href=/tags/android>android</a>)</div><div class=summary-body><p><h3 id=0x00-安卓的-jni>0x00 安卓的 JNI</h3><p>安卓开发中，JNI 就是 Java Native Interface 的缩写，它允许 Java 代码调用原生的 C/C++ 代码，或者允许 C/C++ 代码调用 Java 代码。</p><p>在 Android Stdio 中，有以下 3 种方法使用 so 文件：</p><a href=https://wyb0.com/posts/2024/android-calls-so-file/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.com/posts/2024/frida-hook-app/>使用 Hook 框架 frida 进行调试</a></h1><div class=post-meta><time>2024-05-15</time>
[<a href=/categories/Pentest>Pentest</a>](<a href=/tags/hook>hook</a>)</div><div class=summary-body><p><h3 id=0x00-frida>0x00 frida</h3><p>1、手机端安装一个 server 程序<br>2、然后把手机端的端口转到 PC 端<br>3、PC 端写 js 脚本进行通信</p><p>frida -U -f com.package.name -l exploit.js</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>hook</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;[*] Starting script&#34;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Java</span>.<span style=color:#a6e22e>perform</span>(<span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>class_reference</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Java</span>.<span style=color:#a6e22e>use</span>(<span style=color:#e6db74>&#34;&lt;package_name&gt;.&lt;class&gt;&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>class_reference</span><span style=color:#f92672>&gt;</span>.<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>method</span><span style=color:#f92672>&gt;</span>.<span style=color:#a6e22e>implementation</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>args</span><span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;hook &lt;class_reference&gt;.&lt;method&gt;()&#34;</span>)
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;args is:&#34;</span>, <span style=color:#a6e22e>args</span>)
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ret</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>method_to_hook</span><span style=color:#f92672>&gt;</span>(<span style=color:#a6e22e>args</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ret</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=0x01-java-层---直接调用函数>0x01 JAVA 层 - 直接调用函数</h3><ul><li><p>调用静态函数</p><a href=https://wyb0.com/posts/2024/frida-hook-app/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.com/posts/2024/extracts-firmware/>固件提取</a></h1><div class=post-meta><time>2024-03-29</time>
[<a href=/categories/Pentest>Pentest</a>](<a href=/tags/bin>bin</a>)</div><div class=summary-body><p><h3 id=0x00-固件组成>0x00 固件组成</h3><p>固件通常由 bootloader、内核、根文件系统及其他资源文件组成<br>固件采用的根系统文件类型有很多种，常见的有 squashfs、ubifs、ext4、jeffs2 等。<br>固件文件通常以 bin、zip、LZMA、arj 等文件压缩类型封装，最常见的为 bin 和 zip 格式<br>最常采用的文件系统是 squashfs，分析人员可以使用 unsqushfs 工具对文件系统提取数据。</p><a href=https://wyb0.com/posts/2024/extracts-firmware/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.com/posts/2024/hardware-interface-test/>硬件接口测试</a></h1><div class=post-meta><time>2024-01-31</time>
[<a href=/categories/Pentest>Pentest</a>](<a href=/tags/hardware>hardware</a>)</div><div class=summary-body><p><h3 id=0x01-jtag-接口>0x01 JTAG 接口</h3><p>主要用来读写固件，常见 JTAG 接口引脚有 10PIN、14PIN、20PIN</p><p>一般需要接的引脚：<br>GND：接地引脚<br>TDI：测试数据输入，用于向被测设备传输测试数据<br>TDO：测试数据输出，用于从被测设备读取测试数据<br>TCK：测试时钟，用于同步测试数据的传输<br>TMS：测试模式选择，用于控制 JTAG 状态机的状态转移<br>TRST：可选，TRST 可以用来对 TAPController 进行复位（初始化）</p><a href=https://wyb0.com/posts/2024/hardware-interface-test/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.com/posts/2023/using-msf-for-pth-and-ptt/>使用 MSF 进行 PtH 和 PtT</a></h1><div class=post-meta><time>2023-03-25</time>
[<a href=/categories/Pentest>Pentest</a>](<a href=/tags/intranet>intranet</a>)</div><div class=summary-body><p><h3 id=0x00-概述>0x00 概述</h3><ul><li><p>环境</p><p>攻击机 MSF：172.20.10.2<br>DC (Server2008R2X64)：10.11.11.5<br>目标机 (Win7ProX86)：10.11.11.14</p><a href=https://wyb0.com/posts/2023/using-msf-for-pth-and-ptt/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.com/posts/2022/kerberos-hash-ticket/>Kerberos 与 NTLM Hash 与 Ticket</a></h1><div class=post-meta><time>2022-10-11</time>
[<a href=/categories/Pentest>Pentest</a>](<a href=/tags/intranet>intranet</a>)</div><div class=summary-body><p><h3 id=0x00-kerberos>0x00 Kerberos</h3><p>Kerberos 协议有两个基础认证模块: AS 和 TGS，以及微软扩展的两个认证模块 S4U 和 PAC。
常见的基于 Kerberos 协议攻击的方法如下图所示：
<img src=/img/post/Xnip2022-10-13_17-09-29.png alt=60></p><h3 id=0x01-kerberos-关键词>0x01 Kerberos 关键词</h3><ul><li>域控制器（Domain Controller，DC）：在域中至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样。</li><li>帐户数据库（Account Database，AD）：一个类似于 Windows 本机 SAM 的数据库，存储了域内所有网络对象的凭证，也存储所有 Client 的白名单，在白名单中的 Client 才可以申请到 TGT。</li><li>密钥分发中心（Key Distribution Center，KDC）：KDC 维护着域中所有安全主体（SecurityPrincipal）账户信息数据库，负责管理票据、认证票据、分发票据，在 Windows 域环境中，KDC 的角色由 DC 承担。</li><li>身份验证服务（Authentication Service，AS）：用于生成 TGT 的服务。</li><li>票据发放服务（Ticket Granting Service，TGS）：用于生成某个服务的 ticket</li><li>认证票据（Ticket Granting Ticket，TGT）：可以理解为入场券，通过入场券能够获得票据，是一种临时凭证的存在。</li><li>票据（Ticket）：网络对象互相访问的凭证。</li><li>Session Key：AS 生成的随机会话密钥。</li><li>Server Session Key：TGS 生成的随机会话密钥。</li><li>krbtgt 账户：每个域控制器都有一个 krbtgt 的用户账户，是 KDC 的服务账户，用来创建票据授予服务(TGS)加密的密钥。</li></ul><h3 id=0x02-kerberos-认证过程>0x02 Kerberos 认证过程</h3><p>认证的大致过程：</p><a href=https://wyb0.com/posts/2022/kerberos-hash-ticket/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.com/posts/2022/jndi/>JNDI 注入</a></h1><div class=post-meta><time>2022-03-30</time>
[<a href=/categories/Pentest>Pentest</a>](<a href=/tags/jdni>jdni</a>,<a href=/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96>反序列化</a>)</div><div class=summary-body><p><h3 id=0x00-jdni>0x00 JDNI</h3><p>JNDI(Java Naming and Directory Interface) 是 Java 提供的 Java 命名和目录接口</p><p>JNDI 可访问的现有的目录及服务有：JDBC、LDAP、RMI、DNS、NIS、CORBA</p><a href=https://wyb0.com/posts/2022/jndi/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.com/posts/2021/gophish/>Gophish 钓鱼测试</a></h1><div class=post-meta><time>2021-09-26</time>
[<a href=/categories/Pentest>Pentest</a>](<a href=/tags/%E9%92%93%E9%B1%BC>钓鱼</a>)</div><div class=summary-body><p><h3 id=0x00-gophish-使用>0x00 Gophish 使用</h3><ul><li>配置 Gophish 服务</li><li>配置发送邮箱</li><li>编写钓鱼邮件内容</li><li>编写钓鱼页面</li><li>添加目标邮箱</li><li>开始攻击</li></ul><h3 id=0x01-配置-gophish-服务>0x01 配置 Gophish 服务</h3><p>在 <a href=https://github.com/gophish/gophish/releases?_blank>https://github.com/gophish/gophish/releases</a> 下载</p><p>然后编辑 config.json，之后直接 ./gophish 运行即可</p><a href=https://wyb0.com/posts/2021/gophish/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.com/posts/2021/php-deserialize-and-string-escaping/>PHP 反序列化与字符串逃逸</a></h1><div class=post-meta><time>2021-07-18</time>
[<a href=/categories/Pentest>Pentest</a>](<a href=/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96>反序列化</a>)</div><div class=summary-body><p><h3 id=0x00-漏洞成因>0x00 漏洞成因</h3><p>该漏洞主要是因为序列化的字符串在经过过滤函数不正确的处理而导致对象注入，目前看到都是因为过滤函数放在了 serialize 函数之后</p><a href=https://wyb0.com/posts/2021/php-deserialize-and-string-escaping/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.com/posts/2021/flask-ssti/>Flask 模版注入（SSTI）</a></h1><div class=post-meta><time>2021-07-11</time>
[<a href=/categories/Pentest>Pentest</a>](<a href=/tags/python>python</a>,<a href=/tags/ctf>ctf</a>,<a href=/tags/rce>rce</a>)</div><div class=summary-body><p><h3 id=0x00-ssti-模版注入>0x00 SSTI 模版注入</h3><p>SSTI 模版注入一般都是先找到执行命令的模块模块，然后执行（可以用工具 tplmap）</p><p>一般步骤：<br>1、某种类型 (字符串:""，list:[]，int：1) 开始引出<br>2、<code>__class__</code> 找到当前类<br>3、<code>__mro__</code> 或者 <code>__base__</code> 或者 <code>__bases__</code> 找到根类 <code>__object__</code><br>4、然后利用 <code>__subclasses__</code> 拿到子类列表<br>5、然后在子类列表 <code>__init__.__globals__.keys()</code> 找到类似 popen 能执行命令的函数</p><a href=https://wyb0.com/posts/2021/flask-ssti/>more...</a></p></div></article><div>1 of 18
<a href=/page/2/>Next Page</a></div></main></div><footer><hr><p id=social>Find me around the web:
<a href=https://github.com/reber0?_blank>GitHub</a>
•
<a href=https://weibo.com/u/5819760166?_blank>Weibo</a></p><p class=copyright>Copyright © 2015-2025
<a href=https://wyb0.com/><strong>Reber</strong></a>.
Built with
<a href=http://www.gohugo.io/>Hugo</a>,
based on the theme
<a href=https://gitlab.com/ian-s-mcb/smigle-hugo-theme>smigle</a>.</p></footer></body></html>