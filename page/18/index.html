<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.140.2"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=author content="Reber"><title>Reber's Blog</title>
<link rel=stylesheet href=/css/reset.css><link rel=stylesheet href=/css/smigle.css><link rel=stylesheet href=/css/monokai-sublime.min.css><link rel=stylesheet href=/css/style.css><script src=/js/jquery-3.6.0.min.js></script><script src=/js/highlight.min.js></script><script src=/js/style.js></script><link rel=icon type=image/img sizes=16x16 href=/img/logo.png><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"></head><body><header><div id=brand><a class=icon-link href=https://wyb0.cn/><img class=icon src=/img/logo.png></a><div class=text><a href=https://wyb0.cn/><h1>Reber's Blog</h1></a><h3>会一点点编程、会一点点渗透</h3></div></div><nav><a href=/><b>Home</b></a>
|
<a href=/posts/><b>Posts</b></a>
|
<a href=/categories/><b>Categories</b></a>
|
<a href=/tags/><b>Tags</b></a>
|
<a href=/about/><b>About</b></a>
|
<a href=/friends/><b>Friends</b></a></nav><hr></header><div id=content><main><article><h1 class=summary-title><a href=https://wyb0.cn/posts/2016/python-regular/>Python 的正则</a></h1><div class=post-meta><time>2016-02-05</time>
[<a href=/categories/Python>Python</a>](<a href=/tags/python>python</a>,<a href=/tags/%E6%AD%A3%E5%88%99>正则</a>)</div><div class=summary-body><p><h3 id=0x00-正则表达式>0x00 正则表达式</h3><p>正则表达式是用来匹配字符串的异常强大的东西，可以用来匹配邮箱、域名等字符串</p><h3 id=0x01-符号>0x01 符号</h3><p><img src=/img/post/regular_atomic_character.png alt=75></p><h3 id=0x02-特殊字符>0x02 特殊字符</h3><p><img src=/img/post/regular_metacharacters.png alt=75></p><h3 id=0x03-常用的模块属性>0x03 常用的模块属性</h3><p><img src=/img/post/regular_modifier.png alt=75></p><a href=https://wyb0.cn/posts/2016/python-regular/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.cn/posts/2016/python-thread/>Python 的线程</a></h1><div class=post-meta><time>2016-02-03</time>
[<a href=/categories/Python>Python</a>](<a href=/tags/python>python</a>,<a href=/tags/thread>thread</a>)</div><div class=summary-body><p><p>Python的参数传递其实传递的是对象，当传递可变对象(列表、队列)时相当于引用传递，可以修改对象的原始值，当传递不可变对象(字符串、整型)时就相当于传值，不能直接修改原始对象。</p><a href=https://wyb0.cn/posts/2016/python-thread/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.cn/posts/2016/python-object-oriented/>Python 的面向对象</a></h1><div class=post-meta><time>2016-01-25</time>
[<a href=/categories/Python>Python</a>](<a href=/tags/python>python</a>)</div><div class=summary-body><p><h3 id=0x00-面向对象>0x00 面向对象</h3><ul><li><p>面向对象是为了解决系统的可维护性，可扩展性，可重用性</p></li><li><p>三个基本特征：封装、继承、多态</p><ul><li><p>封装：对一类事物，将其相同特点和功能提取出来，所共有的特点叫做属性，共有的功能就叫做方法，将属性和方法组合在一起就叫做封装。<br>如：人具有姓名、年龄、性别，这些就是属性，人可以说话、可以走、可以跑，这些就是方法，封装起来就是一个类，而类的实例化就是对象</p><a href=https://wyb0.cn/posts/2016/python-object-oriented/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.cn/posts/2016/python-functional-programming/>Python 的函数式编程</a></h1><div class=post-meta><time>2016-01-21</time>
[<a href=/categories/Python>Python</a>](<a href=/tags/python>python</a>)</div><div class=summary-body><p><h3 id=0x00-函数式编程>0x00 函数式编程</h3><p>首先说一下高阶函数，能将函数作为参数来接收的函数就可以称为高阶函数，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add</span>(x,y,f):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> f(x) <span style=color:#f92672>+</span> f(y)
</span></span><span style=display:flex><span>print add(<span style=color:#ae81ff>7</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>3</span>,abs) <span style=color:#75715e>#abs是求绝对值的函数，这里返回的值为10</span>
</span></span></code></pre></div><p>将函数作为参数传入，这样的函数就是高阶函数，而函数式编程就是指这种抽象程度很高的编程范式。<br>函数式编程的一个特点就是可以将函数作为参数，还允许返回一个函数。<br>纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。<br>允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p><a href=https://wyb0.cn/posts/2016/python-functional-programming/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.cn/posts/2015/injection-of-asp-in-the-cookie/>ASP Cookie 处联合注入</a></h1><div class=post-meta><time>2015-12-04</time>
[<a href=/categories/Pentest>Pentest</a>](<a href=/tags/SQL%E6%B3%A8%E5%85%A5>SQL注入</a>)</div><div class=summary-body><p><h3 id=0x00-cookie注入的使用>0x00 Cookie注入的使用</h3><ul><li><p>三大Web提交方式</p><ul><li>GET：直接在浏览器上面访问地址</li><li>POST：提交表单(会员注册、文件上传等)</li><li>COOKIE：访问网站下面自带的身份验证的值</li></ul></li><li><p>Cookie注入利用时机<br>当用普通注入时，采用and 1=1时出现错误提示(如下图)，普通的注入就没办法了，可以尝试大小写，编码等绕过，若过滤严谨，无法绕过，这时就可以采用cookie注入。
<img src=/img/post/cookie_injection_conditions.png alt=Cookie注入条件></p><a href=https://wyb0.cn/posts/2015/injection-of-asp-in-the-cookie/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.cn/posts/2015/set-up-dns-server/>搭建 DNS 服务器</a></h1><div class=post-meta><time>2015-07-14</time>
[<a href=/categories/Server>Server</a>](<a href=/tags/Server>Server</a>)</div><div class=summary-body><p><p>环境: ubuntu-16.04.7-server-amd64.iso</p><p>安装系统时选上 dns 服务，或者 apt install bind9 安装</p><h3 id=0x01-配置前>0x01 配置前</h3><ul><li>涉及到的几个配置文件</li></ul><pre tabindex=0><code>/etc/bind/named.conf，主配置文件，通过 include 关键字加载其他仨配置文件
/etc/bind/named.conf.options，转发器配置文件
/etc/bind/named.conf.local，用户配置文件，一般存放 DNS 记录
/etc/bind/named.default-zones，默认区域文件
/etc/bind/aaa.com.zone，正向解析文件
/etc/bind/aaa.com.arpa，反向解析文件
</code></pre><ul><li>备份</li></ul><pre tabindex=0><code>cp /etc/bind/named.config.local /etc/bind/named.config.local.bak
cp /etc/bind/named.config.options /etc/bind/named.config.options.bak
</code></pre><h3 id=0x02-配置-namedconfoptions>0x02 配置 named.conf.options</h3><p>first 先转发给 forwarders 列表进行查询，查询不到再查本地</p><a href=https://wyb0.cn/posts/2015/set-up-dns-server/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.cn/posts/2015/small-and-medium-enterprise-network-structures/>中小企业网络搭建</a></h1><div class=post-meta><time>2015-07-13</time>
[<a href=/categories/Other>Other</a>](<a href=/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87>网络设备</a>)</div><div class=summary-body><p><h3 id=0x00-中小企业需求分析>0x00 中小企业需求分析</h3><ol><li>搭建企业私有局域网络环境，使用交换机、路由器等网络设备完成由局域网到互联网的接入。</li><li>对网络设备能够方便地进行远程管理。</li><li>在局域网中公司部门间进行vlan划分，实现安全管理。</li><li>对三层设备路由技术这方面采取RIPV2协议或OSPF协议。</li><li>配置访问控制列表（ACL）以对网络数据进行有效的分类和控制，限制终端之间的相互访问。</li><li>内网通过配置PAT技术实现与外网之间的通信。</li></ol><h3 id=0x01-所需设备>0x01 所需设备</h3><p><img src=/img/post/enterprise_network_the_required_equipment.png alt=中小企业所需设备></p><a href=https://wyb0.cn/posts/2015/small-and-medium-enterprise-network-structures/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.cn/posts/2015/single-des-simple-implementation/>利用 C 语言简单实现单重 DES</a></h1><div class=post-meta><time>2015-05-22</time>
[<a href=/categories/C>C</a>](<a href=/tags/des>des</a>,<a href=/tags/C-%E8%AF%AD%E8%A8%80>C 语言</a>)</div><div class=summary-body><p><h3 id=0x00-简介>0x00 简介</h3><pre tabindex=0><code>此程序通过单重des实现8个字节的加密和解密。
新建一个工程，这个工程需要3个cpp文件(c文件也可以)和2个头文件。
cpp文件：main.cpp、des.cpp、status.cpp
头文件：des.h、status.h
</code></pre><h3 id=0x01-代码>0x01 代码</h3><ul><li>以下为主函数main.cpp的内容：</li></ul><pre tabindex=0><code>#include &lt;stdio.h&gt;
#include &#34;status.h&#34;
#include &#34;des.h&#34;

int main()
{
    char M[8],Key[9];
    printf(&#34;Input Plaintext :&#34;);
    scanf(&#34;%s&#34;,&amp;M);
    printf(&#34;Input Key :&#34;);
    scanf(&#34;%s&#34;,&amp;Key);

    SetKey(Key);//生成16个子秘钥

    printf(&#34;加密：&#34;);
    Des(M,&#39;e&#39;);
    printf(&#34;%s\n&#34;,M);

    printf(&#34;解密：&#34;);
    Des(M,&#39;d&#39;);
    printf(&#34;%s\n&#34;,M);
    
    return 0;
}
</code></pre><ul><li>以下为des.cpp的内容：</li></ul><pre tabindex=0><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &#34;status.h&#34;
#include &#34;des.h&#34;

void ByteToBit(const char *In,bool *Out,int bits)
{
    for (int j=0;j&lt;bits;j++)
        Out[j]=(In[j/8]&gt;&gt;(j%8))&amp; 1;
}

void BitToByte(bool *In,char *Out,int bits)
{
    memset(Out,0,(bits+7)/8);
    for (int k=0;k&lt;bits;k++)
        Out[k/8]|=In[k]&lt;&lt;(k%8);
}

void Transform(bool *Y,bool *X,const char *Table,int len)
{
    for (int l=0;l&lt;len;l++)
        Temp[l]=X[Table[l]-1];
    memcpy(Y,Temp,len);
}

void Des(char *m,char ch)
{
    bool Tem[32];
    ByteToBit(m,P,64);
    Transform(P,P,IP1_Table,64);
    Li=&amp;P[0];
    Ri=&amp;P[32];

    if (ch==&#39;e&#39;)
    {
        for (i=0;i&lt;16;i++)
        {
            memcpy(Tem,Ri,32);//临时存放明文的右半部分
            f(Ri,SubKey[i]);
            XOR(Ri,Li,32);
            memcpy(Li,Tem,32);//将明文的右半部分写入Li
        }
    } 
    else
    {
        for (i=15;i&gt;=0;i--)
        {
            memcpy(Tem,Li,32);//临时存放明文的右半部分
            f(Li,SubKey[i]);
            XOR(Li,Ri,32);
            memcpy(Ri,Tem,32);//将明文的右半部分写入Li
        }
    }

    Transform(P,P,IP2_Table,64);
    BitToByte(P,m,64);
}

void f(bool *R,bool *k)
{
    bool T[48];
    Transform(T,R,E_Table,48);//32位的Ri扩展为48位
    XOR(T,k,48);//Ri和轮秘钥的异或
    S_Box_f(T,R);
    Transform(R,R,P_Table,32);
}

void XOR(bool *R,bool *k,int len)
{
    for (int m=0;m&lt;len;m++)
        R[m]=R[m]^k[m];
}

void S_Box_f(bool *B,bool *C)
{
    int a,b;
    for (int k=0;k&lt;8;k++)
    {
        a=B[0]*2+B[5];
        b=B[1]*8+B[2]*4+B[3]*2+B[4];
        ByteToBit(&amp;S_Box[k][a][b],C,4);
        B+=6;
        C+=4;
    }
}

//以下求得子秘钥
void SetKey(char *KEY)
{
    ByteToBit(KEY,K,64);
    Transform(K,K,PC1_Table,56);
    printf(&#34;\n\n\n&#34;);
    Ci=&amp;K[0];
    Di=&amp;K[28];
    for (int j=0;j&lt;16;j++)
    {
        MovKey(Ci,28,LOOP_Table[j]);
        MovKey(Di,28,LOOP_Table[j]);
        Transform(SubKey[j],K,PC2_Table,48);
    }
}

void MovKey(bool *LR,int len,int loop)
{
    memcpy(Temp,LR,loop);
    memcpy(LR,LR+loop,len-loop);
    memcpy(LR+len-loop,Temp,loop);
}
</code></pre><ul><li>以下为status.cpp中的内容：</li></ul><pre tabindex=0><code>#include &#34;status.h&#34;

int i;
bool P[64],K[64];
bool *Li,*Ri;
bool *Ci,*Di;
bool Temp[100];
bool SubKey[16][48];

//子密钥各轮移位位数
const char LOOP_Table[16]={
	1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1
};

//16轮乘积变换前的初始变换
const char IP1_Table[64]={
	58, 50, 42, 34, 26, 18, 10, 2,
		60, 52, 44, 36, 28, 20, 12, 4,
		62, 54, 46, 38, 30, 22, 14, 6,
        64, 56, 48, 40, 32, 24, 16, 8,
        57, 49, 41, 33, 25, 17, 9,  1,
        59, 51, 43, 35, 27, 19, 11, 3,
        61, 53, 45, 37, 29, 21, 13, 5,
        63, 55, 47, 39, 31, 23, 15, 7
};

//16轮乘积变换后的逆初始变换
const char IP2_Table[64]={
	40, 8, 48, 16, 56, 24, 64, 32,
		39, 7, 47, 15, 55, 23, 63, 31,
        38, 6, 46, 14, 54, 22, 62, 30,
        37, 5, 45, 13, 53, 21, 61, 29,
        36, 4, 44, 12, 52, 20, 60, 28,
        35, 3, 43, 11, 51, 19, 59, 27,
        34, 2, 42, 10, 50, 18, 58, 26,
        33, 1, 41, 9,  49, 17, 57, 25
};

//扩展置换，将32位的数据扩展为48位
const char E_Table[48]={
	32, 1,  2,  3,  4,  5,
		4,  5,  6,  7,  8,  9,
		8,  9,  10, 11, 12, 13,
		12, 13, 14, 15, 16, 17,
		16, 17, 18, 19, 20, 21,
		20, 21, 22, 23, 24, 25,
		24, 25, 26, 27, 28, 29,
		28, 29, 30, 31, 32, 1
};

//经过S盒后的P置换
const char P_Table[32]={
	16, 7,  20, 21, 29, 12, 28, 17,
		1,  15, 23, 26, 5,  18, 31, 10,
		2,  8,  24, 14, 32, 27, 3,  9,
		19, 13, 30, 6,  22, 11, 4,  25
};

//子密钥换位表PC-1
const char PC1_Table[56]={
	57, 49, 41, 33, 25, 17, 9,
		1,  58, 50, 42, 34, 26, 18,
		10, 2,  59, 51, 43, 35, 27,
		19, 11, 3,  60, 52, 44, 36,
		63, 55, 47, 39, 31, 33, 15,
		7,  62, 54, 46, 38, 30, 22,
		14, 6,  61, 53, 45, 37, 29,
		21, 13, 5,  28, 20, 12, 4
};

//子密钥换位表PC-2(去掉了PC-1的最后一列)
const char PC2_Table[48]={
	14, 17, 11, 24, 1,  5,
		3,  28, 15, 6,  21, 10,
		23, 19, 12, 4,  26, 8,
		16, 7,  27, 20, 13, 2,
		41, 52, 31, 37, 47, 55,
		30, 40, 51, 45, 33, 48,
		44, 49, 39, 56, 34, 53,
		46, 42, 50, 36, 29, 32
};

//S盒
const char S_Box[8][4][16]={
	{
		{14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7},//S1
		{0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8},
		{4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0},
		{15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13}
	},
	{
		{15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10},//S2
		{3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5},
		{0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15},
		{13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9}
	},
	{
		{10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8},//S3
		{13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1},
		{13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7},
		{1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12}
	},
	{
		{7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15},//S4
		{13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9},
		{10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4},
		{3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14}
	},
	{
		{2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9},//S5
		{14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6},
		{4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14},
		{11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3}
	},
	{
		{12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11},//S6
		{10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8},
		{9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6},
		{4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13}
	},
	{
		{4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1},//S7
		{13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6},
		{1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2},
		{6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12}
	},
	{
		{13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7},//S8
		{1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2},
		{7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8},
		{2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11}
	}
};
</code></pre><ul><li>以下为des.h的内容：</li></ul><pre tabindex=0><code>//函数的声明

void ByteToBit(const char *In,bool *Out,int bits);//将字节转换为位
void BitToByte(bool *In,char *Out,int bits);//将位转换为字节
void Transform(bool *Y,bool *X,const char *Table,int len);//按表变换位置
void SetKey(char *KEY);//生成子秘钥
void MovKey(bool *LR,int len,int loop);//秘钥的LS移位
void Des(char *m,char ch);//DES
void XOR(bool *R,bool *k,int len);//异或
void S_Box_f(bool *B,bool *C);//在S盒置换
void f(bool *Ri,bool *k);//f函数
</code></pre><ul><li>以下为status.h的内容：</li></ul><pre tabindex=0><code>//变量的声明

extern int i;
extern bool P[64],K[64];//存放明文和秘钥
extern bool *Li,*Ri;//指向明文的左右两部分
extern bool *Ci,*Di;//指向子秘钥的左右两部分
extern bool Temp[100];
extern bool SubKey[16][48];//存放16轮的秘钥

extern const char IP1_Table[64];
extern const char IP2_Table[64];
extern const char E_Table[48];
extern const char P_Table[32];
extern const char PC1_Table[56];
extern const char PC2_Table[48];
extern const char LOOP_Table[16];
extern const char S_Box[8][4][16];
</code></pre><h3 id=0x02-执行结果>0x02 执行结果</h3><p><img src=/img/post/des.png alt=单重DES运行结果></p><a href=https://wyb0.cn/posts/2015/single-des-simple-implementation/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.cn/posts/2015/cisco-switch-basic-configuration/>思科交换机基本配置</a></h1><div class=post-meta><time>2015-05-06</time>
[<a href=/categories/Other>Other</a>](<a href=/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87>网络设备</a>)</div><div class=summary-body><p><h3 id=0x00-简单配置命令>0x00 简单配置命令</h3><pre tabindex=0><code>Switch&gt;enable(配置交换机名称)
Switch(config)#hostname S

S(config)#enable password 222//(加密特权密码，密码为222)
S(config)#no enable password //(取消enable密码)
S(config)#enable secret 333//(设置后用show命令时不能看到密码)
S(config)#no enable secret //(取消enable密码)

S(config)#line vty 0 4//(有5个虚拟终端，即0-4)
S(config-line)#password 444//(设置虚拟终端密码)
S(config-line)#login//(使密码生效)

S(config)#line console 0//(设置控制台密码)
S(config-line)#password 111
S(config-line)#login
S(config)#line con 0//(取消控制台密码)
S(config-line)#no password

S(config-line)#exec-timeout 5 30//(超时时间)(分、秒)

S(config)#no ip domain-lookup//(禁止名称解析)
</code></pre><h3 id=0x01-配置交换机管理ip默认网关>0x01 配置交换机管理IP、默认网关</h3><pre tabindex=0><code>S(config)#interface vlan 1  //(配置交换机管理IP、子网掩码)
S(config-if)#ip address 192.168.1.1 255.255.255.0
S(config-if)#no shutdown

S(config)#  exit
S(config)#ip default-gateway 192.168.1.250//(默认网关)
</code></pre><h3 id=0x02-配置交换机的端口速率端口双工模式>0x02 配置交换机的端口速率、端口双工模式</h3><pre tabindex=0><code>S(config)#//(端口双工模式)
S(config)#interface f0/1
S(config-if)#duplex ?
  auto  Enable AUTO duplex configuration
  full  Force full duplex operation
  half  Force half-duplex operation
S(config-if)#duplex auto

S(config-if)#speed ? // (配置交换机的端口速率)
  10    Force 10 Mbps operation
  100   Force 100 Mbps operation
  auto  Enable AUTO speed configuration
S(config-if)#speed 100

Switch#write  //(保存配置)
Building configuration...
[OK]
</code></pre></p></div></article><div><a href=/page/17/>Previous Page</a>
18 of 18</div></main></div><footer><hr><p id=social>Find me around the web:
<a href=https://github.com/reber0?_blank>GitHub</a>
•
<a href=https://weibo.com/u/5819760166?_blank>Weibo</a></p><p class=copyright>Copyright © 2015-2025
<a href=https://wyb0.cn/><strong>Reber</strong></a>.
Built with
<a href=http://www.gohugo.io/>Hugo</a>,
based on the theme
<a href=https://gitlab.com/ian-s-mcb/smigle-hugo-theme>smigle</a>.</p></footer></body></html>