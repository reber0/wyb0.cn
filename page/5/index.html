<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.140.2"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=author content="Reber"><title>Reber's Blog</title>
<link rel=stylesheet href=/css/reset.css><link rel=stylesheet href=/css/smigle.css><link rel=stylesheet href=/css/monokai-sublime.min.css><link rel=stylesheet href=/css/style.css><script src=/js/jquery-3.6.0.min.js></script><script src=/js/highlight.min.js></script><script src=/js/style.js></script><link rel=icon type=image/img sizes=16x16 href=/img/logo.png><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"></head><body><header><div id=brand><a class=icon-link href=https://wyb0.com/><img class=icon src=/img/logo.png></a><div class=text><a href=https://wyb0.com/><h1>Reber's Blog</h1></a><h3>会一点点编程、会一点点渗透</h3></div></div><nav><a href=/><b>Home</b></a>
|
<a href=/posts/><b>Posts</b></a>
|
<a href=/categories/><b>Categories</b></a>
|
<a href=/tags/><b>Tags</b></a>
|
<a href=/about/><b>About</b></a>
|
<a href=/friends/><b>Friends</b></a></nav><hr></header><div id=content><main><article><h1 class=summary-title><a href=https://wyb0.com/posts/2017/dns-zone-transfer/>DNS 域传送漏洞</a></h1><div class=post-meta><time>2017-11-20</time>
[<a href=/categories/Pentest>Pentest</a>](<a href=/tags/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2>信息泄露</a>)</div><div class=summary-body><p><h3 id=0x00-dns域传送>0x00 DNS域传送</h3><p>DNS服务器分为：主服务器、备份服务器和缓存服务器，在主备服务器之间则通过“DNS域传送”同步数据。</p><p>若DNS服务器配置不当，可能导致匿名用户获取某个域的所有记录，从而节省许多搜集资产的时间。</p><a href=https://wyb0.com/posts/2017/dns-zone-transfer/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.com/posts/2017/middleware-security-configuration/>中间件安全配置</a></h1><div class=post-meta><time>2017-10-28</time>
[<a href=/categories/Server>Server</a>](<a href=/tags/server>server</a>)</div><div class=summary-body><p><h3 id=0x00-apache>0x00 Apache</h3><ul><li>服务器安全配置</li></ul><pre tabindex=0><code>#查看服务器运行权限
$ ps aux|grep apache|grep -v grep
$ sudo lsof -i:80
COMMAND    PID     USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
apache2   1377     root    4u  IPv6  12596      0t0  TCP *:http (LISTEN)
apache2  21121 www-data    4u  IPv6  12596      0t0  TCP *:http (LISTEN)
apache2  21122 www-data    4u  IPv6  12596      0t0  TCP *:http (LISTEN)
apache2  21123 www-data    4u  IPv6  12596      0t0  TCP *:http (LISTEN)
apache2  21124 www-data    4u  IPv6  12596      0t0  TCP *:http (LISTEN)
apache2  21125 www-data    4u  IPv6  12596      0t0  TCP *:http (LISTEN)
apache2  24800 www-data    4u  IPv6  12596      0t0  TCP *:http (LISTEN)
apache2 127488 www-data    4u  IPv6  12596      0t0  TCP *:http (LISTEN)

第一行是Apache主进程，以root权限运行的，因为Apache的Web端口是80或443，而在Ubuntu(Linux)中开启小于1024的端口需要root权限，所以主进程必须以root权限运行。
第二行起为Apache子进程，其执行用户为www-data，www-data是Ubuntu中运行Web服务的默认用户，权限较低。

Windows中Apache安装完成后默认是administrator权限，所以需要降权，创建一个用户Apache，用户组为Guests，然后将Apache目录下的日志的可写权限赋给Guests账户。
</code></pre><pre tabindex=0><code>#目录及文件权限
修改配置文件，vim /etc/apache2/apache2.conf解决目录遍历漏洞
#Options Indexes FollowSymLinks
Options FollowSymLinks

或者使用chmod进行权限限制也可以,比如使用chmod o-r flag.txt命令将www-data的读权限去掉

windows也可以通过配置文件或者权限的设置达到上面设置的效果
</code></pre><pre tabindex=0><code>#错误重定向一
$ sudo vim /etc/apache2/apache2.conf
&lt;Directory /var/www/&gt;
        Options Indexes FollowSymLinks
        #AllowOverride None
        AllowOverride All #设置如此
        Require all granted
&lt;/Directory&gt;
$ cat .htaccess
ErrorDocument 404 /404.html

#错误重定向二
$ sudo vim /etc/apache2/apache2.conf
LoadModule rewrite_module modules/mod_rewrite.so #去掉前面的注释符
$ sudo a2enmod rewrite #开启跳转
$ cat .htaccess
ErrorDocument 404 /404.html
RewriteEngine on
RewriteRule &#34;ttt\.html$&#34; aa.html
</code></pre><pre tabindex=0><code>#隐藏apache版本号
$ sudo vim /etc/apache2/conf-available/security.conf
ServerTokens Prod
ServerSignature Off

#隐藏php版本号
$ sudo vim /etc/php5/apache2/php.ini
expose_php =  Off
</code></pre><pre tabindex=0><code>#禁止执行脚本
$ vim /etc/apache2/apache2.conf
&lt;Directory /var/www/html/upload/&gt; #禁止执行php
    php_flag engine off
&lt;/Directory&gt;
</code></pre><ul><li>Apache日志格式</li></ul><p>vim /etc/apache2/apache2.conf</p><a href=https://wyb0.com/posts/2017/middleware-security-configuration/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.com/posts/2017/docker-volume/>Docker 之数据卷</a></h1><div class=post-meta><time>2017-09-19</time>
[<a href=/categories/Linux>Linux</a>](<a href=/tags/docker>docker</a>)</div><div class=summary-body><p><h3 id=0x00-为什么使用数据卷>0x00 为什么使用数据卷</h3><pre tabindex=0><code>Docker镜像是由多个文件系统(只读层)叠加而成的。
当一个容器启动时Docker会加载只读镜像层并在其上添加一个读写层。
读写层中的修改在镜像重新启动后会全部丢失。
在Docker中，只读层及在顶部的读写层的组合被称为Union File System(联合文件系统)。

如果想要保存数据，则可以使用数据卷来在容器外面保存数据，主要为如下两种方式：
* 使用docker run运行容器时指定数据卷
* 在Dockerfile中直接指定数据卷
</code></pre><h3 id=0x01-通过docker-run挂载volume使用-v参数>0x01 通过docker run挂载Volume(使用-v参数)</h3><ul><li>不指定主机目录</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#运行完后容器中的根目录下就会多个data文件夹，这个就是数据卷</span>
</span></span><span style=display:flex><span>$ docker run -itd --name v_test -v /data debian:jessie /bin/bash
</span></span><span style=display:flex><span>root@d145e8c6f874:/# ls
</span></span><span style=display:flex><span>bin   data  etc   lib    media  opt   root  sbin  sys  usr
</span></span><span style=display:flex><span>boot  dev   home  lib64  mnt    proc  run   srv   tmp  var
</span></span><span style=display:flex><span>root@d145e8c6f874:/# exit
</span></span><span style=display:flex><span>exit
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#查看数据卷的对应位置，前者是宿主机的位置，后者是容器中的位置</span>
</span></span><span style=display:flex><span>$ docker inspect -f <span style=color:#f92672>{{</span>.Mounts<span style=color:#f92672>}}</span> v_test
</span></span><span style=display:flex><span><span style=color:#f92672>[{</span>volume 8f39f7de0f851e0bfbcfdd4561fbb20484f01f864ce00a159b09bdcdf743e068 /var/lib/docker/volumes/8f39f7de0f851e0bfbcfdd4561fbb20484f01f864ce00a159b09bdcdf743e068/_data /data local  true <span style=color:#f92672>}]</span>
</span></span></code></pre></div><ul><li>指定主机目录(只能通过-v参数实现，Dockerfile不行)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 本机的/home/var/docker_data和容器的/data对应</span>
</span></span><span style=display:flex><span>$ docker run -itd -v /home/var/docker_data:/data debian:jessie /bin/bash
</span></span><span style=display:flex><span>root@d853c4ca7632:/# exit
</span></span><span style=display:flex><span>exit
</span></span><span style=display:flex><span>$ docker inspect -f <span style=color:#f92672>{{</span>.Mounts<span style=color:#f92672>}}</span> d853c4ca7632
</span></span><span style=display:flex><span><span style=color:#f92672>[{</span>bind  /home/var/docker_data /data   true rprivate<span style=color:#f92672>}]</span>
</span></span><span style=display:flex><span>$ docker inspect -f <span style=color:#f92672>{{</span>.Mounts<span style=color:#f92672>}}</span> d853c4ca7632
</span></span><span style=display:flex><span><span style=color:#f92672>[{</span>bind  /home/var/docker_data /data   true rprivate<span style=color:#f92672>}]</span>
</span></span></code></pre></div><pre tabindex=0><code># 本机创建文件，容器中就会同时出现
#宿主机创建文件
$ sudo touch /home/var/docker_data/a.txt

#容器可以查看到文件同样被创建
root@8e1ccd30fe33:/# ls data/
a.txt
</code></pre><h3 id=0x02-通过dockerfile声明volume>0x02 通过Dockerfile声明Volume</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>FROM debian:jessie VOLUME /data <span style=color:#75715e>#之后的任何命令都不能更改Volume的任何东西</span>
</span></span></code></pre></div><h3 id=0x03-数据共享>0x03 数据共享</h3><p>使用&ndash;volumes-from参数项即可访问另外一个容器的Volume。<br>因为数据容器不启动也可以被其它容器访问，所以一般不推荐启动数据容器。</p><a href=https://wyb0.com/posts/2017/docker-volume/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.com/posts/2017/docker-dockerfile/>Docker 之 Dockerfile</a></h1><div class=post-meta><time>2017-08-18</time>
[<a href=/categories/Linux>Linux</a>](<a href=/tags/docker>docker</a>)</div><div class=summary-body><p><p>操作系统：macOS Sierra 10.12.6<br>Docker版本：Docker version 18.09.0, build 4d60db4</p><h3 id=0x00-dockerfile>0x00 Dockerfile</h3><pre tabindex=0><code>Dockerfile里面其实是一条条的指令，Docker会把Dockerfile的指令翻译为linux命令，
每一条指令都会创建一个镜像，下一条指令将在这个镜像的基础上进行修改操作后再生成一个镜像。
让你可以对下载好的镜像进行一些操作(比如安装软件、向镜像复制文件等)，从而构造定制化的镜像。
</code></pre><h3 id=0x01-dockerfile基本指令>0x01 Dockerfile基本指令</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>FROM &lt;image name&gt;：指定新的镜像基于什么创建<span style=color:#f92672>(</span>可以尝试使用alpine:latest和debian:jessie<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>MAINTAINER &lt;author name&gt;：设置该镜像的作者
</span></span><span style=display:flex><span>COPY &lt;source&gt; &lt;dest&gt;：复制文件，dest要以 / 结尾
</span></span><span style=display:flex><span>WORKDIR /path/to/workdir：相当于切换目录，对RUN、CMD、和ENTRYPOINT生效
</span></span><span style=display:flex><span>RUN &lt;command&gt;：在shell执行命令
</span></span><span style=display:flex><span>EXPOSE port1 port2：容器运行时监听的端口
</span></span><span style=display:flex><span>CMD：容器默认的执行命令，Dockerfile只允许使用一次CMD命令<span style=color:#f92672>(</span>使用数组<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>ENTRYPOINT：类似于CMD，Dockerfile只允许使用一次<span style=color:#f92672>(</span>使用数组<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>ENV &lt;key&gt; &lt;value&gt;：设置环境变量
</span></span><span style=display:flex><span>USER &lt;uid&gt;：镜像正在运行时设置一个uid，即设定启动容器的用户，默认为root
</span></span><span style=display:flex><span>VOLUME <span style=color:#f92672>[</span><span style=color:#e6db74>&#39;/data&#39;</span><span style=color:#f92672>]</span>：授权访问从容器内到主机的目录
</span></span></code></pre></div><p>CMD与ENTRYPOINT的区别：</p><a href=https://wyb0.com/posts/2017/docker-dockerfile/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.com/posts/2017/docker-image-and-container/>Docker 之镜像与容器</a></h1><div class=post-meta><time>2017-08-18</time>
[<a href=/categories/Linux>Linux</a>](<a href=/tags/docker>docker</a>)</div><div class=summary-body><p><p>操作系统：Ubuntu14.04.1<br>Docker版本：Docker version 17.06.0-ce, build 02c1d87</p><h3 id=0x00-镜像操作>0x00 镜像操作</h3><ul><li>下载镜像</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#一般镜像、容器的id和name可以互换</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ docker search ubuntu <span style=color:#75715e>#从公共registry搜索镜像</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ docker pull ubuntu <span style=color:#75715e>#从公共registry下载镜像</span>
</span></span><span style=display:flex><span>$ docker pull ubuntu:14.04
</span></span></code></pre></div><ul><li>查看当前系统镜像</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker images
</span></span><span style=display:flex><span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span style=display:flex><span>ubuntu              14.04               7e4b16ae8b23        <span style=color:#ae81ff>11</span> days ago         188MB
</span></span><span style=display:flex><span>ubuntu              latest              1d9c17228a9e        <span style=color:#ae81ff>11</span> days ago         86.7MB
</span></span></code></pre></div><ul><li>查看镜像层组成</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker history ubuntu:14.04 <span style=color:#75715e># ubuntu:14.04可以用7e4b16ae8b23替代，用id和images_name:tag效果一样</span>
</span></span></code></pre></div><ul><li>删除镜像(删除镜像前要先删除上面的容器)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker rmi ubuntu:latest <span style=color:#75715e># 也可docker rmi 1d9c17228a9e</span>
</span></span></code></pre></div><h3 id=0x01-容器操作>0x01 容器操作</h3><ul><li><p>运行容器(exit后容器就停止了)</p><a href=https://wyb0.com/posts/2017/docker-image-and-container/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.com/posts/2017/docker-basis/>Docker 初识</a></h1><div class=post-meta><time>2017-08-15</time>
[<a href=/categories/Linux>Linux</a>](<a href=/tags/docker>docker</a>)</div><div class=summary-body><p><h3 id=0x00-关于docker>0x00 关于Docker</h3><ul><li>Docker中的镜像类似VM的快照，容器类似虚拟机，使用镜像创建容器类似于使用快照创建虚拟机。</li><li>Docker中运行应用的是容器，容器的创建和销毁在秒级就能完成。</li><li>Docker使用了AUFS，可以以递进的方式创建"VM"，一个"VM"叠在另一个"VM"上，就像使用git增量开发一样。</li><li>软件的运行环境（image）和软件本身（container）分离，和数据也分离。</li></ul><p>学习Docker需要了解4个概念：镜像、容器、数据卷、链接</p><a href=https://wyb0.com/posts/2017/docker-basis/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.com/posts/2017/introduction-to-https-encryption-principles/>[转] HTTPS 加密原理简介</a></h1><div class=post-meta><time>2017-08-01</time>
[<a href=/categories/Other>Other</a>](<a href=/tags/https>https</a>)</div><div class=summary-body><p><p>原文链接：http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html</p><a href=https://wyb0.com/posts/2017/introduction-to-https-encryption-principles/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.com/posts/2017/python-read-and-write-xml/>使用 Python 读写 xml 文件</a></h1><div class=post-meta><time>2017-07-20</time>
[<a href=/categories/Python>Python</a>](<a href=/tags/python>python</a>,<a href=/tags/xml>xml</a>)</div><div class=summary-body><p><h3 id=0x00-解析xml的方法>0x00 解析XML的方法</h3><ol><li><p>SAX (simple API for XML)<br>python 标准库包含SAX解析器，SAX用事件驱动模型，通过在解析XML的过程中触发一个个的事件并调用用户定义的回调函数来处理XML文件。</p><a href=https://wyb0.com/posts/2017/python-read-and-write-xml/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.com/posts/2017/python-module-mrq/>MRQ 的使用</a></h1><div class=post-meta><time>2017-07-10</time>
[<a href=/categories/Python>Python</a>](<a href=/tags/python>python</a>,<a href=/tags/module>module</a>)</div><div class=summary-body><p><h3 id=0x00-mrq>0x00 MRQ</h3><ul><li>MRQ是Python基于Redis、Mongo和gevent的分布式任务队列。</li><li>MRQ一方面旨在像RQ一样简单，另一方面有接近Celery的性能。</li><li>MRQ最初的功能设计是为了满足任务队列的各种任务需求(IO密集&amp;CPU密集，很多小任务&几个大任务)。</li></ul><h3 id=0x01-设置mongo和redis>0x01 设置mongo和redis</h3><p>因为mrq依赖于redis和mongo，所以先安装设置下</p><a href=https://wyb0.com/posts/2017/python-module-mrq/>more...</a></p></div></article><article><h1 class=summary-title><a href=https://wyb0.com/posts/2017/ajax-cross-domain/>AJAX 之跨域</a></h1><div class=post-meta><time>2017-06-22</time>
[<a href=/categories/JS>JS</a>](<a href=/tags/js>js</a>)</div><div class=summary-body><p><h3 id=0x00-简介>0x00 简介</h3><p>当使用AJAX请求其他域名下的数据时会出现拒绝访问的情况，这是出于安全考虑，AJAX只能访问本地的资源，而不能跨域访问。</p><a href=https://wyb0.com/posts/2017/ajax-cross-domain/>more...</a></p></div></article><div><a href=/page/4/>Previous Page</a>
5 of 18
<a href=/page/6/>Next Page</a></div></main></div><footer><hr><p id=social>Find me around the web:
<a href=https://github.com/reber0?_blank>GitHub</a>
•
<a href=https://weibo.com/u/5819760166?_blank>Weibo</a></p><p class=copyright>Copyright © 2015-2025
<a href=https://wyb0.com/><strong>Reber</strong></a>.
Built with
<a href=http://www.gohugo.io/>Hugo</a>,
based on the theme
<a href=https://gitlab.com/ian-s-mcb/smigle-hugo-theme>smigle</a>.</p></footer></body></html>