<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=author content="Reber"><title>Docker 之数据卷 | Reber's Blog</title>
<link rel=stylesheet href=/css/reset.css><link rel=stylesheet href=/css/smigle.css><link rel=stylesheet href=/css/monokai-sublime.min.css><link rel=stylesheet href=/css/style.css><script src=/js/jquery-3.6.0.min.js></script><script src=/js/highlight.min.js></script><script src=/js/style.js></script><link rel=icon type=image/img sizes=16x16 href=/img/logo.png><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"></head><body><header><div id=brand><a class=icon-link href=https://wyb0.com/><img class=icon src=/img/logo.png></a><div class=text><a href=https://wyb0.com/><h1>Reber's Blog</h1></a><h3>会一点点编程、会一点点渗透</h3></div></div><nav><a href=/><b>Home</b></a>
|
<a href=/posts/><b>Posts</b></a>
|
<a href=/categories/><b>Categories</b></a>
|
<a href=/tags/><b>Tags</b></a>
|
<a href=/about/><b>About</b></a>
|
<a href=/friends/><b>Friends</b></a></nav><hr></header><div id=content><main><article><h1>Docker 之数据卷</h1><div class=post-meta><time>2017-09-19</time>
[<a href=/categories/Linux>Linux</a>](<a href=/tags/docker>docker</a>)</div><div><h3 id=0x00-为什么使用数据卷>0x00 为什么使用数据卷</h3><pre tabindex=0><code>Docker镜像是由多个文件系统(只读层)叠加而成的。
当一个容器启动时Docker会加载只读镜像层并在其上添加一个读写层。
读写层中的修改在镜像重新启动后会全部丢失。
在Docker中，只读层及在顶部的读写层的组合被称为Union File System(联合文件系统)。

如果想要保存数据，则可以使用数据卷来在容器外面保存数据，主要为如下两种方式：
* 使用docker run运行容器时指定数据卷
* 在Dockerfile中直接指定数据卷
</code></pre><h3 id=0x01-通过docker-run挂载volume使用-v参数>0x01 通过docker run挂载Volume(使用-v参数)</h3><ul><li>不指定主机目录</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#运行完后容器中的根目录下就会多个data文件夹，这个就是数据卷</span>
</span></span><span style=display:flex><span>$ docker run -itd --name v_test -v /data debian:jessie /bin/bash
</span></span><span style=display:flex><span>root@d145e8c6f874:/# ls
</span></span><span style=display:flex><span>bin   data  etc   lib    media  opt   root  sbin  sys  usr
</span></span><span style=display:flex><span>boot  dev   home  lib64  mnt    proc  run   srv   tmp  var
</span></span><span style=display:flex><span>root@d145e8c6f874:/# exit
</span></span><span style=display:flex><span>exit
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#查看数据卷的对应位置，前者是宿主机的位置，后者是容器中的位置</span>
</span></span><span style=display:flex><span>$ docker inspect -f <span style=color:#f92672>{{</span>.Mounts<span style=color:#f92672>}}</span> v_test
</span></span><span style=display:flex><span><span style=color:#f92672>[{</span>volume 8f39f7de0f851e0bfbcfdd4561fbb20484f01f864ce00a159b09bdcdf743e068 /var/lib/docker/volumes/8f39f7de0f851e0bfbcfdd4561fbb20484f01f864ce00a159b09bdcdf743e068/_data /data local  true <span style=color:#f92672>}]</span>
</span></span></code></pre></div><ul><li>指定主机目录(只能通过-v参数实现，Dockerfile不行)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 本机的/home/var/docker_data和容器的/data对应</span>
</span></span><span style=display:flex><span>$ docker run -itd -v /home/var/docker_data:/data debian:jessie /bin/bash
</span></span><span style=display:flex><span>root@d853c4ca7632:/# exit
</span></span><span style=display:flex><span>exit
</span></span><span style=display:flex><span>$ docker inspect -f <span style=color:#f92672>{{</span>.Mounts<span style=color:#f92672>}}</span> d853c4ca7632
</span></span><span style=display:flex><span><span style=color:#f92672>[{</span>bind  /home/var/docker_data /data   true rprivate<span style=color:#f92672>}]</span>
</span></span><span style=display:flex><span>$ docker inspect -f <span style=color:#f92672>{{</span>.Mounts<span style=color:#f92672>}}</span> d853c4ca7632
</span></span><span style=display:flex><span><span style=color:#f92672>[{</span>bind  /home/var/docker_data /data   true rprivate<span style=color:#f92672>}]</span>
</span></span></code></pre></div><pre tabindex=0><code># 本机创建文件，容器中就会同时出现
#宿主机创建文件
$ sudo touch /home/var/docker_data/a.txt

#容器可以查看到文件同样被创建
root@8e1ccd30fe33:/# ls data/
a.txt
</code></pre><h3 id=0x02-通过dockerfile声明volume>0x02 通过Dockerfile声明Volume</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>FROM debian:jessie VOLUME /data <span style=color:#75715e>#之后的任何命令都不能更改Volume的任何东西</span>
</span></span></code></pre></div><h3 id=0x03-数据共享>0x03 数据共享</h3><p>使用&ndash;volumes-from参数项即可访问另外一个容器的Volume。<br>因为数据容器不启动也可以被其它容器访问，所以一般不推荐启动数据容器。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#启动一个容器，使用v_test这个容器的数据卷，v_test没有启动，但依然有data这个数据卷</span>
</span></span><span style=display:flex><span>$ docker run -itd --volumes-from v_test debian:jessie /bin/bash
</span></span><span style=display:flex><span>root@65aedf9c2ee1:/# ls
</span></span><span style=display:flex><span>bin   data  etc   lib    media  opt   root  sbin  sys  usr
</span></span><span style=display:flex><span>boot  dev   home  lib64  mnt    proc  run   srv   tmp  var
</span></span><span style=display:flex><span>root@65aedf9c2ee1:/# exit
</span></span><span style=display:flex><span>exit
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#可以看下65aedf9c2ee1这个容器的数据卷和v_test数据卷在宿主机对应的是同一个文件夹</span>
</span></span><span style=display:flex><span>$ docker inspect -f <span style=color:#f92672>{{</span>.Mounts<span style=color:#f92672>}}</span> 65aedf9c2ee1
</span></span><span style=display:flex><span><span style=color:#f92672>[{</span>volume 8f39f7de0f851e0bfbcfdd4561fbb20484f01f864ce00a159b09bdcdf743e068 /var/lib/docker/volumes/8f39f7de0f851e0bfbcfdd4561fbb20484f01f864ce00a159b09bdcdf743e068/_data /data local  true <span style=color:#f92672>}]</span>
</span></span></code></pre></div><h3 id=0x04-删除volumes>0x04 删除Volumes</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker rm -v d145e8c6f874 <span style=color:#75715e>#删除容器时一起删除数据</span>
</span></span></code></pre></div><h4 id=reference侵删>Reference(侵删)：</h4><ul><li><a href=http://dockone.io/article/128?_blank>http://dockone.io/article/128</a></li></ul></div></article></main></div><footer><hr><p id=social>Find me around the web:
<a href=https://github.com/reber0?_blank>GitHub</a>
•
<a href=https://weibo.com/u/5819760166?_blank>Weibo</a></p><p class=copyright>Copyright © 2015-2025
<a href=https://wyb0.com/><strong>Reber</strong></a>.
Built with
<a href=http://www.gohugo.io/>Hugo</a>,
based on the theme
<a href=https://gitlab.com/ian-s-mcb/smigle-hugo-theme>smigle</a>.</p></footer></body></html>