<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>module on </title>
    <link>https://wyb0.com/tags/module/</link>
    <description>Recent content in module on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 29 Jan 2018 16:45:34 +0800</lastBuildDate>
    
	<atom:link href="https://wyb0.com/tags/module/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Python中执行系统命令</title>
      <link>https://wyb0.com/posts/2018/python-run-cmd/</link>
      <pubDate>Mon, 29 Jan 2018 16:45:34 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2018/python-run-cmd/</guid>
      <description>0x00 使用模块 在python执行系统命令一般可以通过3个模块来实现，这三个模块是：os、commands、subprocess
0x01 os模块执行系统命令 一般用os模块的system函数来执行一些简单的命令
&amp;gt;&amp;gt;&amp;gt; import os &amp;gt;&amp;gt;&amp;gt; os.system(&amp;quot;pwd&amp;quot;) /Users/reber 0  0x02 commands模块执行系统命令 commands这个模块在python3中被移除了
&amp;gt;&amp;gt;&amp;gt; import commands &amp;gt;&amp;gt;&amp;gt; commands.getoutput(&amp;quot;pwd&amp;quot;) &#39;/Users/reber&#39; &amp;gt;&amp;gt;&amp;gt; commands.getstatusoutput(&amp;quot;pwd&amp;quot;) (0, &#39;/Users/reber&#39;) #返回状态码以及结果  0x03 subprocess模块执行系统命令  task.py代码  def aaa(): s = 0 for x in range(3): time.sleep(1) s += x return s print(aaa())   call函数执行命令(会阻塞到任务完成)
函数原型：subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False)  &amp;gt;&amp;gt;&amp;gt; from subprocess import call &amp;gt;&amp;gt;&amp;gt; call([&amp;quot;ls&amp;quot;,&amp;quot;-l&amp;quot;]) #传入一个list total 16 -rw-r--r-- 1 reber staff 80 8 16 16:19 README.</description>
    </item>
    
    <item>
      <title>MRQ的使用</title>
      <link>https://wyb0.com/posts/2017/python-module-mrq/</link>
      <pubDate>Mon, 10 Jul 2017 16:30:43 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2017/python-module-mrq/</guid>
      <description>0x00 MRQ  MRQ是Python基于Redis、Mongo和gevent的分布式任务队列。 MRQ一方面旨在像RQ一样简单，另一方面有接近Celery的性能。 MRQ最初的功能设计是为了满足任务队列的各种任务需求(IO密集&amp;amp;CPU密集，很多小任务&amp;amp;几个大任务)。  0x01 设置mongo和redis 因为mrq依赖于redis和mongo，所以先安装设置下
 安装redis  $ sudo apt-get install redis-server $ netstat -nlt|grep 6379 $ sudo /etc/init.d/redis-server status  $ sudo /etc/init.d/redis-server stop $ sudo vim /etc/redis/redis.conf #bind 127.0.0.1 requirepass reber_redis $ sudo redis-server /etc/redis/redis.conf &amp;amp; $ redis-cli &amp;gt; auth reber_redis   安装mongo  可以参考：https://docs.mongodb.com/master/tutorial/install-mongodb-on-ubuntu/
$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6 $ echo &amp;quot;deb [ arch=amd64 ] http://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.</description>
    </item>
    
    <item>
      <title>Python的模块</title>
      <link>https://wyb0.com/posts/2016/python-module/</link>
      <pubDate>Wed, 31 Aug 2016 11:22:41 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-module/</guid>
      <description>0x00 Python的模块  在python中，任何一个python文件都可以看作一个模块 不同包下有相同模块名并不会冲突，且包下必须有文件__init__.py from lib import * 意思是从包lib中导入所有模块(若lib为模块名则为导入模块的所有函数) from lib.module1 import test 意思是从lib这个包下的module1模块中导入函数test import导入模块时会从sys.path输出的结果路径中查找模块然后导入 sys.path.append(&#39;D:/xx/xx/xx/code&#39;)可以添加搜索路径 使用if __name__ == &#39;__main__&#39;:  0x01 实例  文件结构如下   测试文件test.py  #!/usr/bin/env python # -*- coding: utf-8 -*- from package1 import * #导入包package1下的所有模块 import package2.module3 #导入包package2下的module3模块 import package2.module4 as s #导入包package2下的module4模块并重命名为s a = module1.Class1() #创建一个对象 a.test() #调用类中的方法 b = module2.Class2() b.test() c = package2.module3.Class3() c.test() d = s.Class4() d.test()   包package1</description>
    </item>
    
    <item>
      <title>Python 命令行参数解析</title>
      <link>https://wyb0.com/posts/2016/python-parames-parse/</link>
      <pubDate>Tue, 16 Aug 2016 15:10:44 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-parames-parse/</guid>
      <description>0x00 argparse 模块 参考 https://docs.python.org/zh-cn/3.7/library/argparse.html
#!/usr/bin/env python # -*- coding: utf-8 -*- import argparse class Parser(object): &amp;quot;&amp;quot;&amp;quot;Parser&amp;quot;&amp;quot;&amp;quot; def __init__(self): super(Parser, self).__init__() self.service_type_list = [ &amp;quot;ssh&amp;quot;,&amp;quot;telnet&amp;quot;,&amp;quot;ftp&amp;quot;, &amp;quot;mysql&amp;quot;,&amp;quot;mssql&amp;quot;,&amp;quot;oracle&amp;quot;,&amp;quot;pgsql&amp;quot;,&amp;quot;redis&amp;quot; ] self.log_level = [&amp;quot;debug&amp;quot;, &amp;quot;info&amp;quot;, &amp;quot;warning&amp;quot;, &amp;quot;error&amp;quot;, &amp;quot;critical&amp;quot;] self.example = &amp;quot;&amp;quot;&amp;quot;Example: \r python3 {} -s ssh -i 123.123.123.123 \r python3 {} -s ssh -i 123.123.123.123/24 -l root -p 123456&amp;quot;&amp;quot;&amp;quot; def parser(self): parser = argparse.ArgumentParser( formatter_class=argparse.RawDescriptionHelpFormatter,#使 example 可以换行 add_help=True, # description = &amp;quot;常见服务口令爆破&amp;quot;, ) parser.</description>
    </item>
    
    <item>
      <title>Python的scapy模块简单使用</title>
      <link>https://wyb0.com/posts/2016/python-module-scapy/</link>
      <pubDate>Thu, 11 Aug 2016 23:26:39 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-module-scapy/</guid>
      <description> 0x00 简单尝试 0x01 生成一组数据包 0x02 发送数据包  send发送数据包  sr1发送数据包  sr发送数据包   0x03 发送SYN数据包 0x04 得到TCP内容 0x05 SYN Scans </description>
    </item>
    
    <item>
      <title>Python的paramiko模块</title>
      <link>https://wyb0.com/posts/2016/python-module-paramiko/</link>
      <pubDate>Thu, 14 Jul 2016 15:24:11 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-module-paramiko/</guid>
      <description> 0x00 安装 直接pip install paramiko安装
或者去http://www.paramiko.org/ 下载
0x01 执行一条远程命令 #!/usr/bin/env python #-*- coding:utf-8 -*- import paramiko #远程执行命令 ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(&amp;quot;192.168.188.134&amp;quot;,22,&amp;quot;reber&amp;quot;,&amp;quot;123456&amp;quot;) ssh_session = ssh.get_transport().open_session() stdin,stdout,stderr = ssh.exec_command(&amp;quot;ls -l&amp;quot;) print stdin print stdout.readlines() #返回执行结果 print stderr.readlines() #有错误信息就返回错误信息，没有就返回空 ssh.close()  0x02 上传与下载文件 #!/usr/bin/env python #-*- coding:utf-8 -*- import paramiko ftp = paramiko.Transport((&amp;quot;192.168.188.134&amp;quot;,22)) ftp.connect(username=&amp;quot;reber&amp;quot;,password=&amp;quot;123456&amp;quot;) sftp = paramiko.SFTPClient.from_transport(ftp) #将本地的文件上传到服务端的/tmp/a.txt remotepath=&#39;/tmp/a.txt&#39; localpath=&#39;C:\\Users\\reber\\Desktop\\a.txt&#39; sftp.put(localpath, remotepath) #将服务端的文件下载到C:\\Users\\reber\\Desktop\\system.log remotepath=&#39;/tmp/a.txt&#39; localpath=&#39;C:\\Users\\reber\\Desktop\\system.log&#39; sftp.get(remotepath, localpath) ftp.close()  </description>
    </item>
    
    <item>
      <title>Python的cmd模块</title>
      <link>https://wyb0.com/posts/2016/python-module-cmd/</link>
      <pubDate>Thu, 14 Jul 2016 09:44:06 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-module-cmd/</guid>
      <description>0x00 关于cmd模块 使用cmd模块创建的命令行解释器可以循环读取输入的所有行并且解析它们
0x01 cmd模块的一些常用方法：  cmdloop()：类似与Tkinter的mainloop，运行Cmd解析器 onecmd(str)：读取输入，并进行处理，通常不需要重载该函数，而是使用更加具体的do_command来执行特定的命名 emptyline()：当输入空行时调用该方法 default(line)：当无法识别输入的command时调用该方法 completedefault(text,line,begidx,endidx):如果不存在针对的complete_*()方法，那么会调用该函数 precmd(line)：命令line解析之前被调用该方法 postcmd(stop，line)：命令line解析之后被调用该方法 preloop()：cmdloop()运行之前调用该方法 postloop()：cmdloop()退出之后调用该方法  0x02 用cmd模块简单实现shell命令 #!/usr/bin/env python #-*- coding:utf-8 -*- import sys import os import socket from cmd import Cmd class ClassShell(Cmd): &amp;quot;&amp;quot;&amp;quot;docstring for ClassShell&amp;quot;&amp;quot;&amp;quot; def __init__(self): Cmd.__init__(self) os.chdir(&amp;quot;C:/Users/reber/Desktop&amp;quot;) hostName = socket.gethostname() self.prompt = &amp;quot;reber@&amp;quot; + hostName + &amp;quot; &amp;quot; + os.path.abspath(&#39;.&#39;) + &amp;quot;\n$ &amp;quot; def help_dir(self): print &amp;quot;dir [path]&amp;quot; def do_dir(self, arg): if not arg: print &amp;quot;\n&amp;quot;.</description>
    </item>
    
  </channel>
</rss>