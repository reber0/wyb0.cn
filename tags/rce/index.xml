<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rce on Reber&#39;s Blog</title>
    <link>https://wyb0.com/tags/rce/</link>
    <description>Recent content in rce on Reber&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 25 Jun 2018 21:26:14 +0000</lastBuildDate>
    <atom:link href="https://wyb0.com/tags/rce/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Struts 2 相关漏洞 payload</title>
      <link>https://wyb0.com/posts/2018/structs2-some-vulnerability-payload/</link>
      <pubDate>Mon, 25 Jun 2018 21:26:14 +0000</pubDate>
      <guid>https://wyb0.com/posts/2018/structs2-some-vulnerability-payload/</guid>
      <description>0x00 S2-001 该漏洞因为用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用 OGNL 表达式 %{value} 进行解析，然后重新填充到对应的表</description>
    </item>
    <item>
      <title>WebLogic 反序列化漏洞 POC (CVE-2017-10271)</title>
      <link>https://wyb0.com/posts/2018/weblogic-cve-2017-10271-poc/</link>
      <pubDate>Fri, 09 Mar 2018 09:20:03 +0000</pubDate>
      <guid>https://wyb0.com/posts/2018/weblogic-cve-2017-10271-poc/</guid>
      <description>0x00 WebLogic WLS 组件反序列化漏洞 这个漏洞的编号是 CVE-2017-10271，漏洞存在于 Oracle WebLogic 的 wls-wsat 组件中，该组件的 XMLDecoder 方法在反序列化时</description>
    </item>
    <item>
      <title>Struts2-046 EXP</title>
      <link>https://wyb0.com/posts/2017/struts2-046/</link>
      <pubDate>Sun, 16 Apr 2017 17:44:01 +0000</pubDate>
      <guid>https://wyb0.com/posts/2017/struts2-046/</guid>
      <description>Struts2 046 前段时间写的struts2 046检测脚本，代码如下： #!/usr/bin/env python # -*- coding: utf-8 -*- # code by reber import sys import pycurl import StringIO def initCurl(): c = pycurl.Curl() c.setopt(pycurl.FOLLOWLOCATION, 1) #允许跟踪来源 c.setopt(pycurl.MAXREDIRS,</description>
    </item>
    <item>
      <title>代码执行漏洞(二)</title>
      <link>https://wyb0.com/posts/2016/code-execution-vulnerabilities-2/</link>
      <pubDate>Fri, 14 Oct 2016 13:16:32 +0000</pubDate>
      <guid>https://wyb0.com/posts/2016/code-execution-vulnerabilities-2/</guid>
      <description>接着上一篇：代码执行漏洞(一) 0x00 函数create_function() php中的函数create_function()可</description>
    </item>
    <item>
      <title>代码执行漏洞(一)</title>
      <link>https://wyb0.com/posts/2016/code-execution-vulnerabilities/</link>
      <pubDate>Mon, 25 Jul 2016 22:32:51 +0000</pubDate>
      <guid>https://wyb0.com/posts/2016/code-execution-vulnerabilities/</guid>
      <description>0x00 代码执行 当应用在调用一些能将字符转化为代码的函数(如PHP中的eval)时，没有考虑用户是否能控制这个字符串，这就会造</description>
    </item>
    <item>
      <title>命令执行漏洞</title>
      <link>https://wyb0.com/posts/2016/command-execution-vulnerabilities/</link>
      <pubDate>Sun, 24 Jul 2016 14:32:51 +0000</pubDate>
      <guid>https://wyb0.com/posts/2016/command-execution-vulnerabilities/</guid>
      <description>0x00 命令执行 应用有时需要调用一些执行系统命令的函数，如PHP中的system、exec、shell_exec、 passth</description>
    </item>
  </channel>
</rss>
