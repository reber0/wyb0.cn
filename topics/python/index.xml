<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on </title>
    <link>https://wyb0.com/topics/python/</link>
    <description>Recent content in Python on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 04 Jul 2019 18:09:49 +0800</lastBuildDate>
    
	<atom:link href="https://wyb0.com/topics/python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>利用 Python 的协程进行快速端口扫描</title>
      <link>https://wyb0.com/posts/2019/python-coroutine-fast-port-scan/</link>
      <pubDate>Thu, 04 Jul 2019 18:09:49 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2019/python-coroutine-fast-port-scan/</guid>
      <description>0x00 协程的优势 协程拥有极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此没有线程切换的开销。和多线程比，线程数量越多，协程的性能优势就越明显。
不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多
0x01 Python中的协程 协程也就是微线程，python 的 generator(生成器) 中的 yield 可以一定程度上实现协程
在 generator 中，我们不但可以通过 for 循环来迭代，还可以不断调用 next() 函数获取由 yield 语句返回的下一个值。
但是 Python 的 yield 不但可以返回一个值，它还可以接收调用者发出的参数。 0x02 使用 gevent python 中可以通过 generator 实现协程，但是不完全，第三方的 gevent 为 Python 提供了比较完善的协程支持，gevent 可以通过 monkey patch 动态的修改 Python 自带的一些标准库
由于 IO 操作(比如访问网络)非常耗时，经常使程序处于等待状态，而 gevent 可以为我们自动切换协程，再在适当的时候切换回来继续执行，这就保证总有 greenlet 在运行，而不是等待 IO
使用 gevent 可以获得极高的并发性能，但 gevent 只能在 Unix/Linux 下运行，在 Windows 下不保证正常安装和运行 下面 3 个网络操作是并发执行的，且结束顺序不同，但只有一个线程
from gevent import monkey; monkey.patch_all() import requests import gevent def get_resp_size(url): print(&#39;GET: %s&#39; % url) html = requests.</description>
    </item>
    
    <item>
      <title>Python中执行系统命令</title>
      <link>https://wyb0.com/posts/2018/python-run-cmd/</link>
      <pubDate>Mon, 29 Jan 2018 16:45:34 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2018/python-run-cmd/</guid>
      <description>0x00 使用模块 在python执行系统命令一般可以通过3个模块来实现，这三个模块是：os、commands、subprocess
0x01 os模块执行系统命令 一般用os模块的system函数来执行一些简单的命令
&amp;gt;&amp;gt;&amp;gt; import os &amp;gt;&amp;gt;&amp;gt; os.system(&amp;quot;pwd&amp;quot;) /Users/reber 0  0x02 commands模块执行系统命令 commands这个模块在python3中被移除了
&amp;gt;&amp;gt;&amp;gt; import commands &amp;gt;&amp;gt;&amp;gt; commands.getoutput(&amp;quot;pwd&amp;quot;) &#39;/Users/reber&#39; &amp;gt;&amp;gt;&amp;gt; commands.getstatusoutput(&amp;quot;pwd&amp;quot;) (0, &#39;/Users/reber&#39;) #返回状态码以及结果  0x03 subprocess模块执行系统命令  task.py代码  def aaa(): s = 0 for x in range(3): time.sleep(1) s += x return s print(aaa())   call函数执行命令(会阻塞到任务完成)
函数原型：subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False)  &amp;gt;&amp;gt;&amp;gt; from subprocess import call &amp;gt;&amp;gt;&amp;gt; call([&amp;quot;ls&amp;quot;,&amp;quot;-l&amp;quot;]) #传入一个list total 16 -rw-r--r-- 1 reber staff 80 8 16 16:19 README.</description>
    </item>
    
    <item>
      <title>使用Python读写xml文件</title>
      <link>https://wyb0.com/posts/2017/python-read-and-write-xml/</link>
      <pubDate>Thu, 20 Jul 2017 14:20:26 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2017/python-read-and-write-xml/</guid>
      <description>0x00 解析XML的方法  SAX (simple API for XML)
python 标准库包含SAX解析器，SAX用事件驱动模型，通过在解析XML的过程中触发一个个的事件并调用用户定义的回调函数来处理XML文件。
 DOM(Document Object Model)
将XML数据在内存中解析成一个树，通过对树的操作来操作XML。
 ElementTree(元素树)
ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少。
   我在这里使用ElementTree  0x01 Element对象的属性 每个Element对象都具有以下属性：
 tag：string对象，表示数据代表的种类 attrib：dictionary对象，表示附有的属性 text：string对象，表示element的内容 tail：string对象，表示element闭合之后的尾迹 若干子元素（child elements）  &amp;gt;&amp;gt;&amp;gt; from xml.etree import ElementTree as ET &amp;gt;&amp;gt;&amp;gt; xml = &amp;quot;&amp;quot;&amp;quot;&amp;lt;books&amp;gt; ... &amp;lt;book id=&#39;37476&#39;&amp;gt;aaaa&amp;lt;/book&amp;gt; ... &amp;lt;book id=&#39;83727&#39;&amp;gt;bbbb&amp;lt;/book&amp;gt; ... &amp;lt;/books&amp;gt;&amp;quot;&amp;quot;&amp;quot; &amp;gt;&amp;gt;&amp;gt; root = ET.fromstring(xml) &amp;gt;&amp;gt;&amp;gt; root.tag &#39;books&#39; &amp;gt;&amp;gt;&amp;gt; child = root.getchildren() &amp;gt;&amp;gt;&amp;gt; child [&amp;lt;Element &#39;book&#39; at 0x106f59410&amp;gt;, &amp;lt;Element &#39;book&#39; at 0x106f59450&amp;gt;] &amp;gt;&amp;gt;&amp;gt; child[0].</description>
    </item>
    
    <item>
      <title>MRQ的使用</title>
      <link>https://wyb0.com/posts/2017/python-module-mrq/</link>
      <pubDate>Mon, 10 Jul 2017 16:30:43 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2017/python-module-mrq/</guid>
      <description>0x00 MRQ  MRQ是Python基于Redis、Mongo和gevent的分布式任务队列。 MRQ一方面旨在像RQ一样简单，另一方面有接近Celery的性能。 MRQ最初的功能设计是为了满足任务队列的各种任务需求(IO密集&amp;amp;CPU密集，很多小任务&amp;amp;几个大任务)。  0x01 设置mongo和redis 因为mrq依赖于redis和mongo，所以先安装设置下
 安装redis  $ sudo apt-get install redis-server $ netstat -nlt|grep 6379 $ sudo /etc/init.d/redis-server status  $ sudo /etc/init.d/redis-server stop $ sudo vim /etc/redis/redis.conf #bind 127.0.0.1 requirepass reber_redis $ sudo redis-server /etc/redis/redis.conf &amp;amp; $ redis-cli &amp;gt; auth reber_redis   安装mongo  可以参考：https://docs.mongodb.com/master/tutorial/install-mongodb-on-ubuntu/
$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6 $ echo &amp;quot;deb [ arch=amd64 ] http://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.</description>
    </item>
    
    <item>
      <title>下载大文件时显示进度条</title>
      <link>https://wyb0.com/posts/2017/python-module-tqdm/</link>
      <pubDate>Sat, 15 Apr 2017 18:49:37 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2017/python-module-tqdm/</guid>
      <description>0x00 作用 在下载大文件时以进度条的形式显示下载进度，如下图所示： 0x01 代码 #!/usr/bin/env python # -*- coding: utf-8 -*- # code by reber &amp;lt;1070018473@qq.com&amp;gt; import requests from tqdm import tqdm def get_vedio(url,name): resp = requests.get(url=url,stream=True) content_size = int(resp.headers[&#39;Content-Length&#39;])/1024/1024 with open(name, &amp;quot;wb&amp;quot;) as f: print &amp;quot;download file {}, total size: {}M&amp;quot;.format(name,content_size) for data in tqdm(iterable=resp.iter_content(1024*1024),total=content_size,unit=&#39;M&#39;): f.write(data) def get_content(filename): data = [] with open(filename) as f: lines = f.readlines() for line in lines: data.append(line.strip()) return data if __name__ == &#39;__main__&#39;: urls = get_content(&#39;urls.</description>
    </item>
    
    <item>
      <title>检测WebLogic是否存在SSRF</title>
      <link>https://wyb0.com/posts/2017/weblogic-ssrf-check/</link>
      <pubDate>Fri, 14 Apr 2017 14:43:52 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2017/weblogic-ssrf-check/</guid>
      <description>0x00 weblogic返回状态 weblogic的ssrf漏洞测试3种状态，返回如下：
 同网段不存在的主机  同网段主机存活但端口不开放  同网段主机存活且端口开放   0x01 检测脚本如下 #!/usr/bin/env python # -*- coding: utf-8 -*- import re import sys import Queue import requests import threading from requests.packages.urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings(InsecureRequestWarning) queue = Queue.Queue() mutex = threading.Lock() class Weblogic_SSRF_Check(threading.Thread): &amp;quot;&amp;quot;&amp;quot;docstring for Weblogic_SSRF_Check&amp;quot;&amp;quot;&amp;quot; def __init__(self, queue): threading.Thread.__init__(self) self.queue = queue def check(self,domain,ip): payload = &amp;quot;uddiexplorer/SearchPublicRegistries.jsp?operator={ip}&amp;amp;rdoSearch=name&amp;amp;txtSearchname=sdf&amp;amp;txtSearchkey=&amp;amp;txtSearchfor=&amp;amp;selfor=Business+location&amp;amp;btnSubmit=Search&amp;quot;.format(ip=ip) url = domain + payload try: html = requests.get(url=url, timeout=15, verify=False).content m = re.</description>
    </item>
    
    <item>
      <title>Python的pycurl模块</title>
      <link>https://wyb0.com/posts/2017/python-module-pycurl/</link>
      <pubDate>Tue, 21 Mar 2017 23:18:50 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2017/python-module-pycurl/</guid>
      <description>0x00 关于cURL cURL可以使用URL的语法模拟浏览器来传输数据，它支持FTP、FTPS、HTTP、HTTPS、GOPHER、TELNET、DICT、FILE以及LDAP等多种协议。
利用cURL可以实现：HTTPS认证、HTTP POST方法、HTTP PUT方法、FTP上传、keyberos认证、代理服务器、cookies、用户名/密码认证、下载文件断点续传、上传文件断点续传、http代理服务器管道等等。
0x01 pycurl常见方法  创建curl对象  c = pycurl.Curl() #创建一个curl对象   设置请求  c.setopt(pycurl.URL,&amp;quot;http://www.baidu.com&amp;quot;) #指定请求的URL c.setopt(pycurl.CONNECTTIMEOUT, 5) #连接的等待时间，设置为0则不等待 c.setopt(pycurl.TIMEOUT, 5) #请求超时时间 c.setopt(pycurl.USERAGENT,&amp;quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:46.0) Gecko/20100101 Firefox/46.0&amp;quot;) #配置User-Agent c.setopt(pycurl.NOPROGRESS, 0) #是否屏蔽下载进度条，非0则屏蔽 c.setopt(pycurl.MAXREDIRS, 5) #指定HTTP重定向的最大数 c.setopt(pycurl.FORBID_REUSE, 1) #完成交互后强制断开连接，不重用 c.setopt(pycurl.FRESH_CONNECT,1) #强制获取新的连接，即替代缓存中的连接 c.setopt(pycurl.DNS_CACHE_TIMEOUT,60) #设置保存DNS信息的时间，默认为120秒 c.setopt(pycurl.HEADERFUNCTION, getheader) #将返回的HTTP HEADER定向到回调函数getheader c.setopt(pycurl.WRITEFUNCTION, getbody) #将返回的内容定向到回调函数getbody c.setopt(pycurl.WRITEHEADER, fileobj) #将返回的HTTP HEADER定向到fileobj文件对象 c.setopt(pycurl.WRITEDATA, fileobj) #将返回的HTML内容定向到fileobj文件对象   部分返回信息  c.getinfo(pycurl.HTTP_CODE) #返回的HTTP状态码 c.</description>
    </item>
    
    <item>
      <title>Python实现CDN的判断</title>
      <link>https://wyb0.com/posts/2016/python-cnd-check/</link>
      <pubDate>Fri, 23 Dec 2016 21:10:05 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-cnd-check/</guid>
      <description>0x00 什么是CDN CDN的全称是Content Delivery Network，即内容分发网络。主要功能是在不同地点缓存内容， 运营商会在全国各地的节点上缓存你的网站网页，通过负载均衡技术，将用户的请求定向到最合适的 缓存服务器上去获取内容，比如说你是上海用户，你访问www.aa.com就会被重定向到上海的节点， 你是北京用户，你也访问www.aa.com，但是你会被重定向到上海的节点。  0x01 判断方法  可以查询CNAME记录，每个cdn厂商都有特有的特征串 查看http返回头的头部信息  0x02 代码 首先安装dnspython这个第三方模块：pip install dnspython
#!/usr/bin/env python # -*- coding: utf-8 -*- import sys import dns.resolver import urllib2 import urlparse class CdnCheck(object): def __init__(self, url): super(CdnCheck, self).__init__() self.cdninfo() self.url = url self.cnames = [] self.headers = [] def get_cnames(self): # get all cname furl = urlparse.urlparse(self.url) url = furl.netloc # print url rsv = dns.</description>
    </item>
    
    <item>
      <title>使用Python的openpyxl模块读写xlsx文件</title>
      <link>https://wyb0.com/posts/2016/python-module-openpyxl/</link>
      <pubDate>Fri, 25 Nov 2016 17:44:23 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-module-openpyxl/</guid>
      <description>0x00 openpyxl模块 这个模块可以让你读写excel文件
0x01 读取数据 代码如下：
#!/usr/bin/env python # -*- coding: utf-8 -*- from openpyxl import load_workbook #设置data_only=True，否则如果文件中有计算公式的话读出来的是公式不是数值 wb = load_workbook(filename=&#39;aa.xlsx&#39;,data_only=True) sheetnames = wb.get_sheet_names() #获得所有表名 print u&amp;quot;存在表：%s&amp;quot; % sheetnames ws = wb.get_sheet_by_name(sheetnames[0]) print u&amp;quot;第一张表表名为：%s&amp;quot; % ws.title #Sheet1 rows = ws.max_row #行数 columns = ws.max_column #列数 print &amp;quot;表%s有%d行%d列&amp;quot; % (ws.title,rows,columns) #10 2 共10行2列 print print u&amp;quot;取部分数据：&amp;quot; print ws[&#39;A1&#39;].value,ws[&#39;B1&#39;].value print ws[&#39;A2&#39;].value,ws[&#39;B2&#39;].value print ws.cell(row=1, column=2).value print u&amp;quot;\n输出表%s的所有数据：&amp;quot; % ws.title for x in range(1,rows+1): for y in range(1,columns+1): print ws.</description>
    </item>
    
    <item>
      <title>Python爆破zip压缩包</title>
      <link>https://wyb0.com/posts/2016/python-blasting-zip-archive/</link>
      <pubDate>Tue, 20 Sep 2016 14:50:59 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-blasting-zip-archive/</guid>
      <description>0x00 代码 多线程爆破加密的zip压缩包
#!/usr/bin/env python # -*- coding: utf-8 -*- import sys import optparse import zipfile import threading import Queue queue = Queue.Queue() lock = threading.Lock() result = &#39;&#39; def load_pwd(filename): for line in open(filename,&#39;r&#39;): if line: queue.put(line.strip()) def bruter(zipname,queue): global result zFile = zipfile.ZipFile(zipname) while not queue.empty(): password = queue.get() try: zFile.extractall(pwd=password) # 解压 lock.acquire() print &amp;quot;[Ok] password is: %s&amp;quot; % password lock.release() result = password except: lock.acquire() print &amp;quot;[Error] password not is: %s&amp;quot; % password lock.</description>
    </item>
    
    <item>
      <title>Python实现代理</title>
      <link>https://wyb0.com/posts/2016/python-implement-agent/</link>
      <pubDate>Tue, 13 Sep 2016 11:36:39 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-implement-agent/</guid>
      <description>0x00 帮助信息 0x01 代码如下 #!/usr/bin/env python # -*- coding: utf-8 -*- &#39;This is a proxy&#39; __author__ = &#39;xxx&#39; import sys import socket import threading import optparse lock = threading.Lock() def locker(msg): lock.acquire() print msg lock.release() def hexdump (src,length=16):#十六进制导出函数 result = [] digits = 4 if isinstance(src,unicode) else 2 for i in xrange(0,len(src),length): s = src[i:i+length] hexa = b&#39; &#39;.join(&amp;quot;[%0*X]&amp;quot; % (digits,ord(x)) for x in s) text = b&#39;&#39;.join([x if 0x20 &amp;lt;= ord(x) &amp;lt; 0x7F else b&#39;.</description>
    </item>
    
    <item>
      <title>Python封装MySQL类</title>
      <link>https://wyb0.com/posts/2016/python-package-mysql-function/</link>
      <pubDate>Mon, 12 Sep 2016 22:54:28 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-package-mysql-function/</guid>
      <description>0x00 安装 有两种，一个是MySQLdb，一个是pymysql
 下载MySQL-python然后安装
 sudo pip install pymysql(推荐，因为py3已经不支持MySQLdb了)  0x01 简单表设计如下 insert into mysql.user(Host,User,Password) values(&#39;%&#39;,&#39;python&#39;,&#39;123456&#39;); drop database if exists python; create database python; use python; drop table if exists msg; create table msg( id int not null auto_increment primary key, ip varchar(40) not null default &#39;127.0.0.1&#39; comment &#39;ip地址&#39;, domain varchar(100) not null default &#39;www.xx.com&#39; comment &#39;域名&#39; ); grant all privileges on python.* to &#39;python&#39;@&#39;%&#39; identified by &#39;123456&#39;; flush privileges;  0x02 MySQLdb封装代码 #!</description>
    </item>
    
    <item>
      <title>POC框架Pocsuite</title>
      <link>https://wyb0.com/posts/2016/poc-framework-pocsuite/</link>
      <pubDate>Thu, 08 Sep 2016 20:38:45 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/poc-framework-pocsuite/</guid>
      <description>0x00 关于Pocsuite Pocsuite 是知道创宇安全研究团队打造的一款基于漏洞与 POC 的远程漏洞验证框架。可以让我们不用考虑过多的细节，只要考虑验证代码就可以，它封装了一些我们常用的东西，比如requests，在我们平常使用requests是要考虑cookie、要考虑header，但是在框架下则不需要有这些考虑，因为这些东西框架都帮你解决了。
0x01 简单介绍  安装  使用pip install pocsuite即可安装   常用参数  -u 指定一个目标url -f 指定一个存放目标url的文件 -r 指定一个存放poc的文件夹 &amp;ndash;report 导出结果到html文件 &amp;ndash;cookie 携带cookie &amp;ndash;referer 修改referer &amp;ndash;user-agent 修改UA  模式  执行一个poc有两种模式  --verify 漏洞验证模式(只是验证，不能更改服务器的东西) --attack 漏洞利用模式  示例  pocsuite -u &amp;quot;http://www.xxxx.com&amp;quot; -r poc_path/poc_name.py --atack   poc编写
 可以新建一个文件夹，命名为mypoc，里面就放你自己写的poc(当然也可以在mypoc里新建文件夹放一类poc，对poc进行分类) 此时示例(对目标进行常见服务的测试，加载一类多个poc脚本)  pocsuite -u &amp;quot;http://www.xxxx.com&amp;quot; -r poc_path/server/ --verify   poc的命名规范
 漏洞ID_版本号_漏洞类型(其中不能有大写字母，所有符号要改为&amp;quot;_&amp;quot;),大致如下：  _xxxx_struct2_2016_s2_016_code_execution.</description>
    </item>
    
    <item>
      <title>Python的模块</title>
      <link>https://wyb0.com/posts/2016/python-module/</link>
      <pubDate>Wed, 31 Aug 2016 11:22:41 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-module/</guid>
      <description>0x00 Python的模块  在python中，任何一个python文件都可以看作一个模块 不同包下有相同模块名并不会冲突，且包下必须有文件__init__.py from lib import * 意思是从包lib中导入所有模块(若lib为模块名则为导入模块的所有函数) from lib.module1 import test 意思是从lib这个包下的module1模块中导入函数test import导入模块时会从sys.path输出的结果路径中查找模块然后导入 sys.path.append(&#39;D:/xx/xx/xx/code&#39;)可以添加搜索路径 使用if __name__ == &#39;__main__&#39;:  0x01 实例  文件结构如下   测试文件test.py  #!/usr/bin/env python # -*- coding: utf-8 -*- from package1 import * #导入包package1下的所有模块 import package2.module3 #导入包package2下的module3模块 import package2.module4 as s #导入包package2下的module4模块并重命名为s a = module1.Class1() #创建一个对象 a.test() #调用类中的方法 b = module2.Class2() b.test() c = package2.module3.Class3() c.test() d = s.Class4() d.test()   包package1</description>
    </item>
    
    <item>
      <title>Python实现密码生成器</title>
      <link>https://wyb0.com/posts/2016/python-password-generator/</link>
      <pubDate>Mon, 29 Aug 2016 15:14:57 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-password-generator/</guid>
      <description>0x00 简介 有时候需要在网上注册许多账号，如果每个账户密码都一样的话，若被别人得知一个密码则所有账户就都沦陷了，若密码不一样则可能会忘记，在这里就用脚本写一个生成密码的工具，只需输入域名和账户名就可以根据key生成不一样的密码，也可以把域名和账户名写入文件，这样你用户名也可以不用记了。。。
0x01 代码如下 #!/usr/bin/env python # -*- coding: utf-8 -*- import hashlib import sys import os import optparse import json import msvcrt def get_md5(string): md5 = hashlib.md5() md5.update(string) s = md5.hexdigest() return s def get_domain(): if os.path.exists(&#39;account.txt&#39;): data = {} with open(&#39;account.txt&#39;, &#39;r&#39;) as f: lines = f.readlines() for line in lines: line = line.split(&#39;*&#39;) data[line[0]] = line[1].strip() else: pass return data def get_pass(): pwd = [] while True: nchar = msvcrt.</description>
    </item>
    
    <item>
      <title>Python实现多线程弱口令爆破</title>
      <link>https://wyb0.com/posts/2016/python-multi-threaded-weak-password-blasting/</link>
      <pubDate>Fri, 26 Aug 2016 17:53:51 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-multi-threaded-weak-password-blasting/</guid>
      <description>0x00 脚本 #!/usr/bin/env python # -*- coding: utf-8 -*- &#39;this script can bruter ftp/ssh/mysql&#39; __author__ = &#39;reber&#39; import Queue import threading import time import logging import socket from optparse import OptionParser import paramiko from ftplib import FTP import MySQLdb #################公有类################# class CommonFun(object): &amp;quot;&amp;quot;&amp;quot;docstring for CommonFun&amp;quot;&amp;quot;&amp;quot; def __init__(self): super(CommonFun, self).__init__() def set_log(self,lname): logger = logging.getLogger(lname) logger.setLevel(logging.DEBUG) ch = logging.StreamHandler() ch.setLevel(logging.DEBUG) formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;) ch.setFormatter(formatter) logger.</description>
    </item>
    
    <item>
      <title>Python 命令行参数解析</title>
      <link>https://wyb0.com/posts/2016/python-parames-parse/</link>
      <pubDate>Tue, 16 Aug 2016 15:10:44 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-parames-parse/</guid>
      <description>0x00 argparse 模块 参考 https://docs.python.org/zh-cn/3.7/library/argparse.html
#!/usr/bin/env python # -*- coding: utf-8 -*- import argparse class Parser(object): &amp;quot;&amp;quot;&amp;quot;Parser&amp;quot;&amp;quot;&amp;quot; def __init__(self): super(Parser, self).__init__() self.service_type_list = [ &amp;quot;ssh&amp;quot;,&amp;quot;telnet&amp;quot;,&amp;quot;ftp&amp;quot;, &amp;quot;mysql&amp;quot;,&amp;quot;mssql&amp;quot;,&amp;quot;oracle&amp;quot;,&amp;quot;pgsql&amp;quot;,&amp;quot;redis&amp;quot; ] self.log_level = [&amp;quot;debug&amp;quot;, &amp;quot;info&amp;quot;, &amp;quot;warning&amp;quot;, &amp;quot;error&amp;quot;, &amp;quot;critical&amp;quot;] self.example = &amp;quot;&amp;quot;&amp;quot;Example: \r python3 {} -s ssh -i 123.123.123.123 \r python3 {} -s ssh -i 123.123.123.123/24 -l root -p 123456&amp;quot;&amp;quot;&amp;quot; def parser(self): parser = argparse.ArgumentParser( formatter_class=argparse.RawDescriptionHelpFormatter,#使 example 可以换行 add_help=True, # description = &amp;quot;常见服务口令爆破&amp;quot;, ) parser.</description>
    </item>
    
    <item>
      <title>Python的scapy模块简单使用</title>
      <link>https://wyb0.com/posts/2016/python-module-scapy/</link>
      <pubDate>Thu, 11 Aug 2016 23:26:39 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-module-scapy/</guid>
      <description> 0x00 简单尝试 0x01 生成一组数据包 0x02 发送数据包  send发送数据包  sr1发送数据包  sr发送数据包   0x03 发送SYN数据包 0x04 得到TCP内容 0x05 SYN Scans </description>
    </item>
    
    <item>
      <title>Python的paramiko模块</title>
      <link>https://wyb0.com/posts/2016/python-module-paramiko/</link>
      <pubDate>Thu, 14 Jul 2016 15:24:11 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-module-paramiko/</guid>
      <description> 0x00 安装 直接pip install paramiko安装
或者去http://www.paramiko.org/ 下载
0x01 执行一条远程命令 #!/usr/bin/env python #-*- coding:utf-8 -*- import paramiko #远程执行命令 ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(&amp;quot;192.168.188.134&amp;quot;,22,&amp;quot;reber&amp;quot;,&amp;quot;123456&amp;quot;) ssh_session = ssh.get_transport().open_session() stdin,stdout,stderr = ssh.exec_command(&amp;quot;ls -l&amp;quot;) print stdin print stdout.readlines() #返回执行结果 print stderr.readlines() #有错误信息就返回错误信息，没有就返回空 ssh.close()  0x02 上传与下载文件 #!/usr/bin/env python #-*- coding:utf-8 -*- import paramiko ftp = paramiko.Transport((&amp;quot;192.168.188.134&amp;quot;,22)) ftp.connect(username=&amp;quot;reber&amp;quot;,password=&amp;quot;123456&amp;quot;) sftp = paramiko.SFTPClient.from_transport(ftp) #将本地的文件上传到服务端的/tmp/a.txt remotepath=&#39;/tmp/a.txt&#39; localpath=&#39;C:\\Users\\reber\\Desktop\\a.txt&#39; sftp.put(localpath, remotepath) #将服务端的文件下载到C:\\Users\\reber\\Desktop\\system.log remotepath=&#39;/tmp/a.txt&#39; localpath=&#39;C:\\Users\\reber\\Desktop\\system.log&#39; sftp.get(remotepath, localpath) ftp.close()  </description>
    </item>
    
    <item>
      <title>Python的cmd模块</title>
      <link>https://wyb0.com/posts/2016/python-module-cmd/</link>
      <pubDate>Thu, 14 Jul 2016 09:44:06 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-module-cmd/</guid>
      <description>0x00 关于cmd模块 使用cmd模块创建的命令行解释器可以循环读取输入的所有行并且解析它们
0x01 cmd模块的一些常用方法：  cmdloop()：类似与Tkinter的mainloop，运行Cmd解析器 onecmd(str)：读取输入，并进行处理，通常不需要重载该函数，而是使用更加具体的do_command来执行特定的命名 emptyline()：当输入空行时调用该方法 default(line)：当无法识别输入的command时调用该方法 completedefault(text,line,begidx,endidx):如果不存在针对的complete_*()方法，那么会调用该函数 precmd(line)：命令line解析之前被调用该方法 postcmd(stop，line)：命令line解析之后被调用该方法 preloop()：cmdloop()运行之前调用该方法 postloop()：cmdloop()退出之后调用该方法  0x02 用cmd模块简单实现shell命令 #!/usr/bin/env python #-*- coding:utf-8 -*- import sys import os import socket from cmd import Cmd class ClassShell(Cmd): &amp;quot;&amp;quot;&amp;quot;docstring for ClassShell&amp;quot;&amp;quot;&amp;quot; def __init__(self): Cmd.__init__(self) os.chdir(&amp;quot;C:/Users/reber/Desktop&amp;quot;) hostName = socket.gethostname() self.prompt = &amp;quot;reber@&amp;quot; + hostName + &amp;quot; &amp;quot; + os.path.abspath(&#39;.&#39;) + &amp;quot;\n$ &amp;quot; def help_dir(self): print &amp;quot;dir [path]&amp;quot; def do_dir(self, arg): if not arg: print &amp;quot;\n&amp;quot;.</description>
    </item>
    
    <item>
      <title>Python简单解码IP头</title>
      <link>https://wyb0.com/posts/2016/python-simple-decode-ip-head/</link>
      <pubDate>Sun, 03 Jul 2016 20:06:39 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-simple-decode-ip-head/</guid>
      <description>0x00 解码IP头 Windows上运行时要以管理员身份运行
代码可以解码IP头统计通信信息并保存到文本，同时统计数量
#!/usr/bin/env python #-*- coding:utf-8 -*- import socket import os import sys import time import struct from ctypes import * host = &amp;quot;10.22.114.114&amp;quot; tcp_num = 0 udp_num = 0 icmp_num = 0 class IP(Structure): _fields_ = [ (&amp;quot;ihl&amp;quot;, c_ubyte,4), (&amp;quot;version&amp;quot;, c_ubyte,4), (&amp;quot;tos&amp;quot;, c_ubyte), (&amp;quot;len&amp;quot;, c_ushort), (&amp;quot;id&amp;quot;, c_ushort), (&amp;quot;offset&amp;quot;, c_ushort), (&amp;quot;ttl&amp;quot;, c_ubyte), (&amp;quot;protocol_num&amp;quot;,c_ubyte), (&amp;quot;sum&amp;quot;, c_ushort), (&amp;quot;src&amp;quot;, c_ulong), (&amp;quot;dst&amp;quot;, c_ulong) ] def __new__ (self,socket_buffer=None): return self.from_buffer_copy(socket_buffer) def __init__ (self,socket_buffer=None): self.</description>
    </item>
    
    <item>
      <title>Python的requests模块</title>
      <link>https://wyb0.com/posts/2016/python-module-requests/</link>
      <pubDate>Sat, 02 Jul 2016 10:47:19 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-module-requests/</guid>
      <description>0x00 无参数的get请求 import requests resp = requests.get(&#39;http://www.baidu.com&#39;,timeout=1) #设置超时，超时后抛出timeout错误 print resp.text #一般用来输出纯文本，可得到unicode类型字符串 print resp.content #一般用来输出pdf、图片等，可得到原网页设定类型的字符串  0x01 有参数的get请求 import requests url = &#39;http://10.10.10.10:8080/Lab2.0/Login.action&#39; header = { &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0&#39;, } param = {&#39;aaa&#39;:&#39;1111&#39;,&#39;bbb&#39;:&#39;2222&#39;} resp = requests.get(url,params=param,headers=header) print resp.url #得到url print resp.status_code #得到返回的状态码 print resp.headers #得到html头 print resp.cookies #得到cookie  0x02 POST请求 import requests url1 = &#39;http://10.10.10.10:8080/Lab2.0/Login.action&#39; url2 = &#39;http://10.10.10.10:8080/Lab2.0/student.action&#39; data = { &#39;userid&#39;:&#39;1315935xxx&#39;, &#39;password&#39;:&#39;xxxxxxx&#39;, &#39;quan&#39;:&#39;Student&#39;, } header = { &#39;User-Agent&#39;: &#39;Mozilla/5.</description>
    </item>
    
    <item>
      <title>Python的编码问题</title>
      <link>https://wyb0.com/posts/2016/python-encode-setting/</link>
      <pubDate>Wed, 29 Jun 2016 15:14:11 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-encode-setting/</guid>
      <description>0x00 几个编码函数 * ord(x) 将字符转换为10进制整数(0~255之间) #ord(&#39;a&#39;)==&amp;gt;97 * chr(x) 将10进制整数(0~255之间)转换为字符 #chr(97)==&amp;gt;&#39;a&#39;，chr(0x61)==&amp;gt;&#39;a&#39; * b2a_hex(x) 将字符转换为对应的16进制 #import binascii;binascii.b2a_hex(&#39;a&#39;)==&amp;gt;&#39;61&#39; * a2b_hex(x) 将16进制转换为对应的字符 #import binascii;binascii.a2b_hex(&#39;61&#39;)==&amp;gt;&#39;a&#39; * hex(x) 将10进制整数转换为对应的16进制 #hex(16)==&amp;gt;&#39;0x10&#39; * oct(x) 将10进制整数转换为对应的8进制 #oct(9)==&amp;gt;&#39;011&#39;  0x01 设置为utf-8  在py文件开头设置
#!/usr/bin/env python #-*- coding: utf-8 -*- 或： #coding=utf8  永久编码(推荐) 可以在python安装路径下的Lib\site-packages下新建文件sitecustomize.py文件，内容如下：
#coding=utf8 import sys reload(sys) sys.setdefaultencoding(&#39;utf8&#39;) # 此方法修改了python环境，设置系统默认编码，永久有效   0x03 编码转换 python默认unicode为中间编码，所以无论是何种编码，解码时默认都解码为unicode
python2中的字符串一般包含两种类型：str和unicode str：str为ascii类型的字符串，utf-8、utf-16、GB2312、GBK等都是ascii类型的字符串 unicode：unicode编码的字符串才是unicode类型的字符串 可通过isinstance()和type()来判断 &amp;gt;&amp;gt;&amp;gt; aa = &#39;小明&#39; &amp;gt;&amp;gt;&amp;gt; isinstance(aa,str) True &amp;gt;&amp;gt;&amp;gt; type(aa) &amp;lt;type &#39;str&#39;&amp;gt; &amp;gt;&amp;gt;&amp;gt; bb = u&#39;小明&#39; &amp;gt;&amp;gt;&amp;gt; isinstance(bb,unicode) True &amp;gt;&amp;gt;&amp;gt; type(bb) &amp;lt;type &#39;unicode&#39;&amp;gt;  &amp;gt;&amp;gt;&amp;gt; u&#39;小明&#39;.</description>
    </item>
    
    <item>
      <title>Python 中通过 logging 和 colorlog 模块记录日志</title>
      <link>https://wyb0.com/posts/2016/python-module-logging-and-colorlog/</link>
      <pubDate>Mon, 27 Jun 2016 08:55:30 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-module-logging-and-colorlog/</guid>
      <description>0x00 使用流程  创建一个 logger 创建相关 handler，同时定义 handler 的输出格式 将 handler 添加到 logger 使用 logger 记录日志  0x01 示例 #!/usr/bin/env python # -*- coding: utf-8 -*- &#39;&#39;&#39; @Author: reber @Mail: reber0ask@qq.com @Date: 2019-07-16 22:31:00 @LastEditTime : 2020-06-16 13:17:05 &#39;&#39;&#39; import logging import colorlog class MyLog(object): &amp;quot;&amp;quot;&amp;quot; MyLog(loglevel, logger_name, logfile=None) &amp;quot;&amp;quot;&amp;quot; def __init__(self, loglevel, logger_name, logfile=None): # 创建一个 logger self.logger = logging.getLogger(logger_name) self.logger.setLevel(logging.DEBUG) # 设置日志输出等级，后面创建 Handler 然后 setLevel(logging.DEBUG) 也不能输出 WARNING 等级之下的日志 # self.</description>
    </item>
    
    <item>
      <title>Python编写规范</title>
      <link>https://wyb0.com/posts/2016/python-coding-style/</link>
      <pubDate>Sun, 12 Jun 2016 22:17:35 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-coding-style/</guid>
      <description>0x00 代码编排 1.缩进：使用4个空格缩进 2.行长度：每行不要超过80个字符 3.空行：顶级定义之间空两行，如函数或类的定义，方法定义、类定义与第一个方法之间都应该空一行。 4.分号：行尾不要有分号，也不要用分号将两条命令放在一行,除非是： 1.长的导入模块语句。 2.注释里的URL. 3.可以使用圆括号实现隐式行连接  0x01文档编排 1.导入：模块注释-&amp;gt;文档字符串-&amp;gt;导入-&amp;gt;模块全局变量-&amp;gt;常量 导入顺序：标准库导入-&amp;gt;第三方库导入-&amp;gt;应用程序指定库导入 2.import:不要在一行中import多个库，一行中只导入一个  0x02 空格 1.不要在逗号、分号、冒号前加空格，但应在他们后面加(除了在行尾) 2.二元操作符(赋值、比较、布尔)两边都加空格 3.当&amp;quot;=&amp;quot;用于指示关键字参数或默认参数值是，不要再其两侧使用空格 4.&amp;quot;,&amp;quot;和&amp;quot;#&amp;quot;和&amp;quot;=&amp;quot;不需要对齐，因为空格会成为维护的负担  0x03 注释 总体原则，错误的注释不如没有注释。 注释必须使用英文，最好是完整的句子，首字母大写，句后要有结束符，结束符后跟两个空格，开始下一句。如果是短语，可以省略结束符。 1.块注释：在一段代码前增加的注释。在&amp;quot;#&amp;quot;后加一空格。段落之间以只有&amp;quot;#&amp;quot;的行间隔。 2.行注释，在一句代码后加注释。进来少使用. 3.绝不要描述代码. 假设阅读代码的人比你更懂Python, 他只是不知道你的代码要做什么.  0x04 文档描述 1.为所有的共有模块、函数、类、方法写docstrings；非共有的没有必要，但是可以写注释（在def的下一行）。 2.如果docstring要换行，参考如下例子 class SampleClass(object): &amp;quot;&amp;quot;&amp;quot;Summary of class here. Longer class information.... Longer class information.... Attributes: likes_spam: A boolean indicating if we like SPAM or not. eggs: An integer count of the eggs we have laid. &amp;quot;&amp;quot;&amp;quot; def __init__(self): &amp;quot;&amp;quot;&amp;quot;Inits SampleClass with blah.</description>
    </item>
    
    <item>
      <title>Python的正则</title>
      <link>https://wyb0.com/posts/2016/python-regular/</link>
      <pubDate>Fri, 05 Feb 2016 11:38:23 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-regular/</guid>
      <description> 0x00 正则表达式 正则表达式是用来匹配字符串的异常强大的东西，可以用来匹配邮箱、域名等字符串
0x01 符号 0x02 特殊字符 0x03 常用的模块属性 0x04 re模块 由于Pyton的字符串本身也用\转义，强烈建议使用r前缀
 函数match()
这个函数会尝试从字符串起始位置匹配一个模式，未匹配到则返回None  函数search()
这个函数会扫描整个字符串并返回第一个成功的匹配，未匹配到则返回None  函数findall()和finditer()
re.findall()将以列表的形式返回所有能匹配到的字符
re.finditer()将以迭代器的形式返回所有能匹配到的字符  函数sub()
这个函数会对字符串进行匹配，然后替换，可以指定替换次数  函数split()
这个函数会以正则来分割字符串，以列表样式返回  函数compile()
这个函数可以编译正则，提高匹配速度   0x05 提取子串 根据正则可以匹配字符然后提取出来，用括号表示要提取的分组 0x06 贪婪匹配 正则表达式默认贪婪匹配，会尽可能的多匹配字符，一般就是用&amp;rdquo;？&amp;rdquo;来抑制贪婪匹配 </description>
    </item>
    
    <item>
      <title>Python的线程</title>
      <link>https://wyb0.com/posts/2016/python-thread/</link>
      <pubDate>Wed, 03 Feb 2016 12:44:38 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-thread/</guid>
      <description>Python的参数传递其实传递的是对象，当传递可变对象(列表、队列)时相当于引用传递，可以修改对象的原始值，当传递不可变对象(字符串、整型)时就相当于传值，不能直接修改原始对象。
0x00 单线程 #!/usr/bin/env python # -*- coding: utf-8 -*- from time import time,ctime,sleep def music(arg): for x in range(2): print &amp;quot;I&#39;m listening to %s. %s&amp;quot; % (arg,ctime()) sleep(1) def movie(arg): for x in range(2): print &amp;quot;I&#39;m watching %s. %s&amp;quot; % (arg,ctime()) sleep(5) if __name__ == &#39;__main__&#39;: start = int(time()) music(u&#39;我&#39;) movie(u&#39;可是&#39;) print &amp;quot;All over time:%s&amp;quot; % ctime() print &amp;quot;Used time:%d&amp;quot; % int(time()-start)  0x01 多线程 #!/usr/bin/env python # -*- coding: utf-8 -*- import re import requests import threading from time import time,ctime,sleep INDEX = 0 def http_get(sites): global INDEX while INDEX &amp;lt; len(sites): url = sites[INDEX] INDEX += 1 resp = requests.</description>
    </item>
    
    <item>
      <title>Python的面向对象</title>
      <link>https://wyb0.com/posts/2016/python-object-oriented/</link>
      <pubDate>Mon, 25 Jan 2016 11:17:59 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-object-oriented/</guid>
      <description>0x00 面向对象  面向对象是为了解决系统的可维护性，可扩展性，可重用性
 三个基本特征：封装、继承、多态
 封装：对一类事物，将其相同特点和功能提取出来，所共有的特点叫做属性，共有的功能就叫做方法，将属性和方法组合在一起就叫做封装。
如：人具有姓名、年龄、性别，这些就是属性，人可以说话、可以走、可以跑，这些就是方法，封装起来就是一个类，而类的实例化就是对象
 继承：继承可以使得子类具有父类的属性和方法，不需要再次编写相同的代码，子类可以对继承的代码进行重写，也可以追加新的属性和方法。
如：有一个类People，教师就可以继承自People，可以添加自己的属性，如：工资、职工号，也可以添加自己的方法，如：备课、写教案
 多态：首先，多态必有继承，没有继承就没有多态，继承后一个父类的引用变量可以指向其任意一个子类对象。
如：有一个People类，它的子类可以有学生、老师、工人，有多种形态，这就是多态
   0x01 类的实例 注意：类中每个方法后面都要写self，self就是当前对象指针
 示例一  #!/usr/bin/env python # -*- coding:utf-8 -*- # 声明一个People类 class People(object): &amp;quot;&amp;quot;&amp;quot;docstring for People&amp;quot;&amp;quot;&amp;quot; def __init__(self, name, age): super(People, self).__init__() self.name = name self.age = age def running(self): print &amp;quot;%s is running&amp;quot; % self.name def print_base_msg(self): print &amp;quot;Name:%s Age:%d&amp;quot; % (self.name,self.age) # 继承自People类 class Teacher(People): &amp;quot;&amp;quot;&amp;quot;docstring for Teacher&amp;quot;&amp;quot;&amp;quot; def __init__(self, name, age, salary): super(Teacher, self).</description>
    </item>
    
    <item>
      <title>Python的函数式编程</title>
      <link>https://wyb0.com/posts/2016/python-functional-programming/</link>
      <pubDate>Thu, 21 Jan 2016 21:13:17 +0800</pubDate>
      
      <guid>https://wyb0.com/posts/2016/python-functional-programming/</guid>
      <description>0x00 函数式编程 首先说一下高阶函数，能将函数作为参数来接收的函数就可以称为高阶函数，如下：
def add(x,y,f): return f(x) + f(y) print add(7,-3,abs) #abs是求绝对值的函数，这里返回的值为10  将函数作为参数传入，这样的函数就是高阶函数，而函数式编程就是指这种抽象程度很高的编程范式。
函数式编程的一个特点就是可以将函数作为参数，还允许返回一个函数。
纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。
允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。
0x01 高阶函数  map()函数
map接收两个参数，一个是函数，一个是列表(list)，map将函数依次作用到list的每个元素，然后返回新的list  def f(x): return x*x print map(f,[1,2,3,4]) #返回[1,4,9,16] print map(str,[1,2,3,4]) # 返回[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;]   reduce()函数
reduce接收参数和map一样(但传入的函数必须接收两个参数)，reduce会对list的每个元素反复调用函数，然后返回最终值  def f(x,y): return x*y print reduce(f,[1,2,3,4]) #1*2*3*4，返回24   filter()函数
filter也接收函数和list，函数会对list的每个元素进行判断然后返回True或False，为True的组成新list返回  def f(x): return x &amp;gt; 3 print filter(f,[1,2,3,4,5]) #返回[4,5]   sorted()函数
Python内置的函数sorted()可以对list进行排序  sorted([34,2,345,3]) #返回[2,3,34,345]  sorted也是一个高阶函数，当然也可以接收函数和参数。通常规定，对于两个元素x和y，若认为x &amp;lt; y则返回-1，若认为x == y则返回0，若认为x &amp;gt; y则返回1，从而进行正向排序</description>
    </item>
    
  </channel>
</rss>